<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sauvegarde on Carnet de découvertes</title><link>https://fljd.in/tags/sauvegarde/</link><description>Recent content in Sauvegarde on Carnet de découvertes</description><generator>Hugo -- gohugo.io</generator><language>fr</language><managingEditor>Florent Jardin</managingEditor><lastBuildDate>Wed, 08 Oct 2025 16:00:00 +0200</lastBuildDate><atom:link href="https://fljd.in/tags/sauvegarde/index.xml" rel="self" type="application/rss+xml"/><item><title>Sauvegardes personnelles avec Restic</title><link>https://fljd.in/2025/10/08/sauvegardes-personnelles-avec-restic/</link><pubDate>Wed, 08 Oct 2025 16:00:00 +0200</pubDate><author>Florent Jardin</author><guid>https://fljd.in/2025/10/08/sauvegardes-personnelles-avec-restic/</guid><description>&lt;p>Ces derniers temps, j’ai mis fin à une histoire d’amour avec Debian qui aura
duré près de trois ans. Pas que je n’aime plus le système, oh non, je le préfère
toujours à sa cousine Ubuntu. Mais voilà, j’ai un attachement particulier à
Archlinux depuis, wouh, au moins les bancs de l’école d’ingénieur où nous
l’installions sur des machines virtuelles et où nous nous adonnions à la
pratique du &lt;a href="https://github.com/fosslife/awesome-ricing" target="_blank" rel="noopener">linux ricing&lt;/a> pour passer le temps.&lt;/p>
&lt;p>Après une expérimentation de &lt;a href="https://manjaro.org/" target="_blank" rel="noopener">Manjaro i3&lt;/a> entre 2019 et 2022 sur mon poste
professionnel, je me suis convaincu qu’il me fallait retourner à l’essentiel. Au
début du mois de septembre, j’ai réussi le portage de ma &lt;a href="https://gitlab.com/fljdin/dotfiles/-/tree/main/sway" target="_blank" rel="noopener">config Sway&lt;/a> de
Debian Trixie vers Archlinux. L’occasion parfaite pour requestionner mes
pratiques en matière de sauvegarde de poste et de remplacer &lt;a href="https://fljd.in/2021/08/24/borg-ou-la-sauvegarde-facile/">BorgBackup&lt;/a> par
Restic.&lt;/p>
&lt;hr>
&lt;h2 id="prise-en-main-éclair">Prise en main éclair&lt;/h2>
&lt;p>J’ai lu plusieurs articles et avis au sujet de Restic. Je l’avais vite identifié
comme un outil équivalent à BorgBackup, mais je ne m’étais pas pressé de le
tester. Quelle erreur ! J’ai été déconcerté par la facilité d’utilisation, par
son interface en ligne de commande claire et complète, et par sa
&lt;a href="https://restic.readthedocs.io/en/stable/010_introduction.html" target="_blank" rel="noopener">documentation&lt;/a> de qualité.&lt;/p>
&lt;p>Pour avoir régulièrement vécu des dégâts sur des clés de mauvaise qualité avec
ma pratique exotique sur BorgBackup, je m’étais penché sur la possibilité de
sauvegarder vers un dossier distant avec SSH. J’ai du insisté deux bonnes heures
à l’époque sans parvenir à quoique ce soit avec Borg.&lt;/p>
&lt;p>Avec Restic, ce n’est pas moins de 13 types différents de dépôts supportés, dont
le &lt;a href="https://restic.readthedocs.io/en/stable/030_preparing_a_new_repo.html#sftp" target="_blank" rel="noopener">SFTP&lt;/a>. Il ne m’en fallait pas plus pour tourner le dos à son homologue. La
mise en place d’un dépôt est simplifiée à l’extrême :&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fish" data-lang="fish">&lt;span class="line">&lt;span class="cl">&lt;span class="k">set&lt;/span> &lt;span class="na">-x&lt;/span> &lt;span class="nv">RESTIC_REPOSITORY&lt;/span> &lt;span class="s2">&amp;#34;sftp:&amp;lt;server&amp;gt;:&amp;lt;directory&amp;gt;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">restic&lt;/span> init
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">restic&lt;/span> backup ~ &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="na">--dry-run&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="na">--exclude-file&lt;/span> ~/.config/restic/excludes.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Je ne suis pas en reste avec une gestion poussée des stratégies de rétention des
instantanés. Pour l’exemple, je maintiens une sauvegarde par semaine, pendant
trois mois.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fish" data-lang="fish">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">restic&lt;/span> forget &lt;span class="na">--prune&lt;/span> &lt;span class="na">--keep-within-weekly&lt;/span> 3m
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>La technique d’exploration d’un instantané est identique à Borg, avec un montage
&lt;a href="https://www.kernel.org/doc/html/latest/filesystems/fuse.html" target="_blank" rel="noopener">FUSE&lt;/a> sous Linux. Une fois encore, la &lt;a href="https://restic.readthedocs.io/en/stable/050_restore.html#restore-using-mount" target="_blank" rel="noopener">documentation&lt;/a> est limpide à ce
sujet.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fish" data-lang="fish">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">sudo&lt;/span> &lt;span class="nf">install&lt;/span> &lt;span class="na">-o&lt;/span> &lt;span class="nv">$USER&lt;/span> &lt;span class="na">-g&lt;/span> &lt;span class="nv">$USER&lt;/span> &lt;span class="na">-d&lt;/span> /mnt/restic
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">restic&lt;/span> mount /mnt/restic
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="planification-avec-systemd">Planification avec systemd&lt;/h2>
&lt;p>Je me suis prêté au même jeu qu’avec BorgBackup sur ma précédente installation
Debian. En lieu et place de &lt;code>cron&lt;/code>, je planifie mes sauvegardes avec un &lt;em>timer&lt;/em>
utilisateur pour déclencher une tâche deux fois par jour sur mes journées de
travail.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-toml" data-lang="toml">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># ~/.config/systemd/user/restic.timer&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="nx">Unit&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">Description&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="nx">Daily&lt;/span> &lt;span class="nx">Restic&lt;/span> &lt;span class="nx">backup&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">Documentation&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="nx">man&lt;/span>&lt;span class="err">:&lt;/span>&lt;span class="nx">restic&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="nx">Timer&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">OnCalendar&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="nx">Mon&lt;/span>&lt;span class="p">..&lt;/span>&lt;span class="nx">Fri&lt;/span> &lt;span class="mi">09&lt;/span>&lt;span class="err">:&lt;/span>&lt;span class="mi">30&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">OnCalendar&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="nx">Mon&lt;/span>&lt;span class="p">..&lt;/span>&lt;span class="nx">Fri&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="err">:&lt;/span>&lt;span class="mi">30&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">Persistent&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="kc">true&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="nx">Install&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">WantedBy&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="nx">timers&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">target&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>La tâche consiste à appeler &lt;code>restic&lt;/code> avec mon fichier d’exclusion, suivi d’une
purge des vieux instantanés présents sur le dépôt.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-toml" data-lang="toml">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># ~/.config/systemd/user/restic.service&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="nx">Unit&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">Description&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="nx">Restic&lt;/span> &lt;span class="nx">backup&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="nx">Service&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">Type&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="nx">oneshot&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">ExecStart&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="nx">restic&lt;/span> &lt;span class="nx">backup&lt;/span> &lt;span class="err">%&lt;/span>&lt;span class="nx">h&lt;/span> &lt;span class="nx">--exclude-file&lt;/span> &lt;span class="err">$&lt;/span>&lt;span class="nx">RESTIC_EXCLUDE_FILE&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">ExecStartPost&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="nx">restic&lt;/span> &lt;span class="nx">forget&lt;/span> &lt;span class="nx">--prune&lt;/span> &lt;span class="nx">--keep-within-weekly&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="nx">m&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Pour la configuration, je déclare les variables dans un fichier d’environnement
pour que &lt;code>restic&lt;/code> sache identifier et déchiffrer correctement les instantanés.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># ~/.config/environment.d/restic.conf&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">RESTIC_REPOSITORY&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">sftp:&amp;lt;server&amp;gt;:&amp;lt;directory&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">RESTIC_PASSWORD_FILE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">$HOME/.config/restic/pass&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">RESTIC_EXCLUDE_FILE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">$HOME/.config/restic/excludes.txt&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Pour armer la planification, il suffit de recharger &lt;code>systemd&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fish" data-lang="fish">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">systemctl&lt;/span> &lt;span class="na">--user&lt;/span> daemon-reload
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>En exportant les bonnes variables dans votre shell, la consultation des
instantanés se fait sobrement avec la commande suivante.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fish" data-lang="fish">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">restic&lt;/span> snapshots
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-console" data-lang="console">&lt;span class="line">&lt;span class="cl">&lt;span class="go">repository 3db74709 opened (version 2, compression level auto)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">ID Time Host Tags Paths Size
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">-----------------------------------------------------------------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">f7bb4fea 2025-09-16 11:50:18 florent-dalibo /home/florent 4.309 GiB
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">5a4dbf59 2025-09-19 09:30:01 florent-dalibo /home/florent 5.639 GiB
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">1012f0ab 2025-09-27 19:28:38 florent-dalibo /home/florent 5.871 GiB
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">629c2687 2025-10-03 09:30:00 florent-dalibo /home/florent 6.006 GiB
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">98b32adb 2025-10-08 10:00:08 florent-dalibo /home/florent 4.677 GiB
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">-----------------------------------------------------------------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">5 snapshots
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>Restic est un bon outil. Tellement bon, que la communauté Gnome l’utilise à
présent comme &lt;em>backend&lt;/em> pour l’interface Déjà Dup dans leur dernière version
49.0 sortie le &lt;a href="https://discourse.gnome.org/t/deja-dup-49-0-released/31441" target="_blank" rel="noopener">mois dernier&lt;/a>.&lt;/p>
&lt;p>Pour ma part, tout se déroule bien depuis presque un mois. Il ne manque plus
qu’à sécuriser le serveur distant qui fait office de dépôt avec ses propres
sauvegardes ! Pour ce faire, j’envisage de mettre en place Restic sur la plupart
des répertoires d’importances de mon serveur multimédia, en gardant bien en
mémoire le principe 3-2-1 de la sauvegarde réussie.&lt;/p>
&lt;p>Prenez soin de vos sauvegardes.&lt;/p></description></item><item><title>BorgBackup ou la sauvegarde facile</title><link>https://fljd.in/2021/08/24/borg-ou-la-sauvegarde-facile/</link><pubDate>Tue, 24 Aug 2021 00:00:00 +0000</pubDate><author>Florent Jardin</author><guid>https://fljd.in/2021/08/24/borg-ou-la-sauvegarde-facile/</guid><description>&lt;p>Jusqu&amp;rsquo;à très récemment, je ne me préoccupais pas de la pertinence de mes
sauvegardes de fichiers personnels réalisées naïvement avec un script &lt;code>rsync&lt;/code>.
C&amp;rsquo;est honteux dans nos métiers, mais l&amp;rsquo;adage du cordonnier s&amp;rsquo;est vérifié avec
moi lors de l&amp;rsquo;exécution d&amp;rsquo;un vulgaire &lt;code>find $NOVAR/ -delete&lt;/code> durant des tests.&lt;/p>
&lt;p>Après cet épisode et l&amp;rsquo;amertume d&amp;rsquo;avoir perdu quelques travaux, ou la surprise
de découvrir les ravages de leur disparition plusieurs semaines après ma fatale
erreur, je me suis tourné vers l&amp;rsquo;outil incontournable dont tous mes collègues me
parlaient : &lt;a href="https://borgbackup.readthedocs.io/en/stable/" target="_blank" rel="noopener">BorgBackup&lt;/a>&lt;/p>
&lt;hr>
&lt;h2 id="des-atouts-séduisants">Des atouts séduisants&lt;/h2>
&lt;p>Cela fait à présent deux années que je travaille au quotidien sur Linux pour mon
activité professionnelle. Étant responsable de mon matériel et des données que
je manipule, il n&amp;rsquo;existe pas de politique particulière pour les sauvegardes
régulières ni le stockage de celles-ci.&lt;/p>
&lt;p>Mon précédent script était passablement trivial, à savoir :&lt;/p>
&lt;ul>
&lt;li>Sauvegarder une copie unique des documents courants ;&lt;/li>
&lt;li>Sauvegarder une liste des fichiers de configuration, appelés &lt;em>dotfiles&lt;/em> ;&lt;/li>
&lt;li>Exclure les projets contenant un répertoire &lt;code>.git&lt;/code> ;&lt;/li>
&lt;li>Exclure les fichiers de plus de 200 Mo.&lt;/li>
&lt;/ul>
&lt;p>Le tout sur une clé USB de 8 Go, chiffrée avec le système &lt;a href="https://fr.wikipedia.org/wiki/LUKS" target="_blank" rel="noopener">LUKS&lt;/a> pour se
prévenir de la perte ou du vol dans un espace public dudit support.&lt;/p>
&lt;p>Borg (son petit nom), permet de répondre correctement à l&amp;rsquo;ensemble de ces
points, et le fait à merveille. En bénéficiant de la déduplication et de la
compression, j&amp;rsquo;ai pu conserver ma clé USB et m&amp;rsquo;engager dans la rédaction d&amp;rsquo;un
&lt;a href="https://gist.github.com/fljdin/de46c7c8d18cc37e591cb8364ecf8eef" target="_blank" rel="noopener">nouveau script&lt;/a> plus complet.&lt;/p>
&lt;p>&lt;strong>Exclusion de fichiers et de répertoires&lt;/strong>&lt;/p>
&lt;p>Certains fichiers ou répertoires cachés vivent leur vie sur nos postes, et un
fichier d&amp;rsquo;exclusion peut être transmis à Borg pour ne pas les inclure dans la
routine de sauvegarde. Le mien est relativement léger pour le moment, et
pourrait s&amp;rsquo;enrichir avec l&amp;rsquo;expérience.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># ~/.config/borg/exclude.list&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/home/**/.git
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/home/**/.vagrant
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/home/*/.local
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/home/*/.cache
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/home/*/.mozilla
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/home/*/.thunderbird
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/home/*/.config/chromium
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/home/*/.config/discord
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/home/*/.npm
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/home/*/.cpan
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Déduplication et rétention d&amp;rsquo;une semaine&lt;/strong>&lt;/p>
&lt;p>Le gain remarquable entre mon script et la nouvelle solution que m&amp;rsquo;offre Borg
réside dans son algorithme de déduplication, où la version d&amp;rsquo;un fichier n&amp;rsquo;est
stockée qu&amp;rsquo;une seule fois jusqu&amp;rsquo;à une éventuelle modification, permettant de ne
conserver qu&amp;rsquo;une copie de mes documents sur une bien plus longue période avec
un coût de stockage ridiculement faible.&lt;/p>
&lt;p>À chaque exécution, je demande le rapport de sauvegarde avec l&amp;rsquo;option &lt;code>--stats&lt;/code>
dont voici un exemplaire sur l&amp;rsquo;exécution de ce matin.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">------------------------------------------------------------------------------
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Archive name: florent-2021-08-24T08:42:05
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Archive fingerprint: be38707dd52f5a86f8e75fe3ad4997aae58b3016366a988b7cb37ce3b
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Time &lt;span class="o">(&lt;/span>start&lt;span class="o">)&lt;/span>: Tue, 2021-08-24 08:42:06
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Time &lt;span class="o">(&lt;/span>end&lt;span class="o">)&lt;/span>: Tue, 2021-08-24 08:42:06
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Duration: 0.96 seconds
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Number of files: &lt;span class="m">3720&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Utilization of max. archive size: 0%
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">------------------------------------------------------------------------------
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Original size Compressed size Deduplicated size
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">This archive: 2.11 GB 1.78 GB 480.51 kB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">All archives: 12.63 GB 10.67 GB 1.75 GB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Unique chunks Total chunks
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Chunk index: &lt;span class="m">3974&lt;/span> &lt;span class="m">25888&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">------------------------------------------------------------------------------
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Pour une semaine de rétention, l&amp;rsquo;espace total consommé sur le montage USB
n&amp;rsquo;excède pas (encore) les 1,75 Go alors que les images décompressées pèsent au
total 12,63 Go que ne parvennait pas à stocker mon ancien script sur plusieurs
jours.&lt;/p>
&lt;p>Au passage, la durée d&amp;rsquo;exécution est significativement réduite chaque jour grâce
à ce mécanisme, qui ne sélectionne que les nouveautés d&amp;rsquo;une exécution à l&amp;rsquo;autre.&lt;/p>
&lt;p>&lt;strong>Un montage virtuel pour naviguer dans le temps&lt;/strong>&lt;/p>
&lt;p>L&amp;rsquo;outil propose deux options pour la restauration :&lt;/p>
&lt;ul>
&lt;li>&lt;code>extract&lt;/code> pour restaurer le contenu d&amp;rsquo;une archive dans le répertoire courant
(&lt;a href="https://borgbackup.readthedocs.io/en/stable/usage/extract.html" target="_blank" rel="noopener">doc&lt;/a>) ;&lt;/li>
&lt;li>&lt;code>mount&lt;/code> pour visualiser les fichiers ou dossiers à restaurer, voire les
déplacer manuellement dans le répertoire cible avec un outil graphique
(&lt;a href="https://borgbackup.readthedocs.io/en/stable/usage/mount.html" target="_blank" rel="noopener">doc&lt;/a>).&lt;/li>
&lt;/ul>
&lt;p>Cette seconde proposition est particulièrement utile pour naviguer d&amp;rsquo;une archive
à une autre, à la recherche d&amp;rsquo;un fichier perdu dans le temps. Le montage
s&amp;rsquo;effectue à l&amp;rsquo;aide du système de fichiers &lt;a href="https://www.kernel.org/doc/html/latest/filesystems/fuse.html" target="_blank" rel="noopener">FUSE&lt;/a> qui ne nécessite aucun
droit administrateur.&lt;/p>
&lt;p>Pour être utilisé à partir de Borg, le paquet &lt;code>python-llfuse&lt;/code> sera requis selon
votre distribution.&lt;/p>
&lt;h2 id="planification-avec-systemd">Planification avec systemd&lt;/h2>
&lt;p>Ce fut une découverte lors de mes lectures émerveillées de la &lt;a href="https://gist.github.com/fljdin/de46c7c8d18cc37e591cb8364ecf8eef" target="_blank" rel="noopener">documentation&lt;/a>
et des &lt;a href="https://wiki.archlinux.org/title/Borg_backup_%28Fran%C3%A7ais%29" target="_blank" rel="noopener">ressources&lt;/a> de la communauté française d&amp;rsquo;Archlinux. N&amp;rsquo;étant pas
particulièrement fan de &lt;code>cron&lt;/code> pour un usage personnel, j&amp;rsquo;ai suivi à la lettre
la configuration d&amp;rsquo;un service utilisateur et du &lt;em>timer&lt;/em> associé pour garantir le
lancement de la sauvegarde chaque jour, 30 minutes après le démarrage de mon
système.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># .config/systemd/user/borg.service&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">[Unit]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">Description&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">Borg backup&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">[Service]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">Type&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">oneshot&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">ExecStart&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">%h/.bin/borg-create.sh&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># .config/systemd/user/borg.timer&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">[Unit]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">Description&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">Daily Borg backup&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">Documentation&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">man:borg&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">[Timer]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">OnBootSec&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">30min&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">OnUnitActiveSec&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">1d&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">[Install]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">WantedBy&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">timers.target&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Une fois le service activé, je n&amp;rsquo;ai qu&amp;rsquo;à attendre chaque matin la notification
de fin de sauvegarde pour consulter les rapports avec la commande &lt;code>journalctl&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">journalctl --user -xeu borg.service
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">août &lt;span class="m">24&lt;/span> 08:42:02 florent systemd&lt;span class="o">[&lt;/span>877&lt;span class="o">]&lt;/span>: Starting Borg backup...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">août &lt;span class="m">24&lt;/span> 08:42:27 florent systemd&lt;span class="o">[&lt;/span>877&lt;span class="o">]&lt;/span>: Finished Borg backup.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">août &lt;span class="m">24&lt;/span> 08:42:27 florent systemd&lt;span class="o">[&lt;/span>877&lt;span class="o">]&lt;/span>: borg.service: Consumed 1.535s CPU time.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>De trop nombreux utilisateurs (Windows notamment) comptent sur leur miraculeuse
corbeille, jusqu&amp;rsquo;à ce qu&amp;rsquo;une véritable suppression ne survienne ou qu&amp;rsquo;un disque
défaillant fasse des siennes. Pour s&amp;rsquo;assurer qu&amp;rsquo;une donnée ne disparaisse pas
définitivement, la sauvegarde doit être correctement mise en place, idéalement
sur plusieurs périodes et sur plusieurs supports.&lt;/p>
&lt;p>Le conseil vaut aussi bien pour les bases de données que pour les fichiers
personnels : une sauvegarde n&amp;rsquo;est fiable que si la restauration de son
contenu est possible. Une corruption de l&amp;rsquo;archive, une erreur dans l&amp;rsquo;exécution
du script ou une mise à jour majeure de l&amp;rsquo;outil de sauvegarde sont autant de
situations qui peuvent rendre vos sauvegardes irrécupérables.&lt;/p>
&lt;p>Prenez soin de vos sauvegardes.&lt;/p></description></item><item><title>La brêve histoire du fichier backup_label</title><link>https://fljd.in/2021/01/19/la-breve-histoire-du-fichier-backup_label/</link><pubDate>Tue, 19 Jan 2021 00:00:00 +0000</pubDate><author>Florent Jardin</author><guid>https://fljd.in/2021/01/19/la-breve-histoire-du-fichier-backup_label/</guid><description>&lt;p>Je suis resté longtemps ignorant des mécanismes de &lt;a href="https://public.dalibo.com/archives/publications/glmf108_postgresql_et_ses_journaux_de_transactions.pdf" target="_blank" rel="noopener">journalisation&lt;/a> et de &lt;em>PITR&lt;/em>
avec PostgreSQL alors même qu&amp;rsquo;il s&amp;rsquo;agit d&amp;rsquo;un des fonctionnements critiques pour
la durabilité des données d&amp;rsquo;une instance. Mieux comprendre ces concepts m&amp;rsquo;aurait
permis à une époque, d&amp;rsquo;être plus serein lors de la mise en place de sauvegardes
et surtout au moment de leur restauration !&lt;/p>
&lt;p>Dans cet article, je vous propose de revenir sur un fichier anecdotique qui a
fait parlé de lui pendant plusieurs années : le fichier &lt;code>backup_label&lt;/code>.
Qui est-il et à quoi sert-il ? Comment a-t-il évolué depuis sa création en
version 8.0 de PostgreSQL et qu&amp;rsquo;adviendra-t-il de lui dans les prochaines années ?&lt;/p>
&lt;hr>
&lt;h2 id="il-était-une-fois-la-journalisation">Il était une fois la journalisation&lt;/h2>
&lt;p>En guise d&amp;rsquo;introduction pour mieux comprendre cet article, il est bon d&amp;rsquo;expliquer
que chaque opération d&amp;rsquo;écriture dans PostgreSQL comme un &lt;code>UPDATE&lt;/code> ou un &lt;code>INSERT&lt;/code>,
est écrite une première fois au moment du &lt;code>COMMIT&lt;/code> de la transaction dans un groupe
de fichiers, que l&amp;rsquo;on appelle &lt;em>WAL&lt;/em> ou &lt;strong>journaux de transactions&lt;/strong>. Ajoutées les
unes à la suite des autres, ces modifications représentent un faible coût pour
l&amp;rsquo;activité des disques par rapport aux écritures aléatoires d&amp;rsquo;autres processus
de synchronisation à l&amp;rsquo;œuvre dans PostgreSQL.&lt;/p>
&lt;p>Parmi l&amp;rsquo;un d&amp;rsquo;eux, le processus &lt;code>checkpointer&lt;/code> s&amp;rsquo;assure que les nouvelles données
en mémoire soient définitivement synchronisées dans les fichiers de données à des
moments réguliers que l&amp;rsquo;on appelle &lt;code>CHECKPOINT&lt;/code>. Cette écriture en deux temps sur
les disques apporte d&amp;rsquo;excellentes performances et garantit qu&amp;rsquo;aucun bloc modifié
ne soit perdu lorsqu&amp;rsquo;une transaction se termine correctement.&lt;/p>
&lt;p>&lt;img src="https://fljd.in/img/fr/2021-01-19-ecriture-differee-sur-disque.png" alt="Écriture différée sur les disques">&lt;/p>
&lt;p>Par ce mécanisme de journalisation, les fichiers de données de notre instance
sont constamment en retard sur la véritable activité transactionnelle, et ce,
jusqu&amp;rsquo;au prochain &lt;code>CHECKPOINT&lt;/code>. En cas d&amp;rsquo;arrêt brutal du système, les blocs en
attente de synchronisation (&lt;em>dirty pages&lt;/em>) présents dans la mémoire &lt;em>Shared Buffer&lt;/em>
sont perdus et les fichiers de données sont dit &lt;strong>incohérents&lt;/strong> car ils mixent
des données de transactions anciennes, nouvelles, valides ou invalides.&lt;/p>
&lt;p>Dans pareilles situations, il est possible de redémarrer l&amp;rsquo;instance afin qu&amp;rsquo;elle
&lt;em>rejoue&lt;/em> les modifications dans l&amp;rsquo;ordre des transactions telles qu&amp;rsquo;elles avaient
été écrites dans les &lt;em>WAL&lt;/em>. Cette reconstruction des fichiers de données pour
retrouver leur état consistant est sobrement appelée la &lt;strong>récupération des données&lt;/strong>
ou &lt;em>crash recovery&lt;/em>.&lt;/p>
&lt;div class="message">En version 8.0 et supérieures, ce mécanisme a permis l&amp;rsquo;émergence des solutions
de restauration dans le temps (&lt;em>Point In Time Recovery&lt;/em>) et de réplication par
récupération des journaux (&lt;em>Log Shipping&lt;/em>) sur une instance secondaire.&lt;/div>
&lt;p>Que ce soit à la suite d&amp;rsquo;un crash ou dans le cadre d&amp;rsquo;une restauration de
sauvegarde, les fichiers de données doivent être cohérents pour assurer le retour
du service et l&amp;rsquo;accès en écriture aux données. Quelle mauvaise surprise n&amp;rsquo;a-t-on
pas lorsqu&amp;rsquo;une instance PostgreSQL interrompt son démarrage avec le message
suivant :&lt;/p>
&lt;p>&lt;code>PANIC: could not locate a valid checkpoint record&lt;/code>&lt;/p>
&lt;p>Il indique que l&amp;rsquo;instance a détecté une inconsistance dans les fichiers au moment
de son démarrage et qu&amp;rsquo;elle échoue à trouver le &lt;em>point de reprise&lt;/em> le plus proche
de son état. Sans les journaux, la récupération échoue et s&amp;rsquo;arrête. À cet instant
précis, vos nerfs et votre politique de sauvegarde sont mis à rude épreuve.&lt;/p>
&lt;p>Pour le dire encore autrement : en l&amp;rsquo;absence des journaux de transactions ou de
leurs archives, &lt;u>vos plus récentes données sont perdues&lt;/u>.&lt;/p>
&lt;p>… Et l&amp;rsquo;outil &lt;a href="https://pgpedia.info/p/pg_resetwal.html" target="_blank" rel="noopener">pg_resetwal&lt;/a> ne les récuperera pas pour vous.&lt;/p>
&lt;hr>
&lt;h2 id="entre-en-scène-le-backup_label">Entre en scène le backup_label&lt;/h2>
&lt;p>Après ce charmant avertissement, on considèrera que l&amp;rsquo;archivage des journaux
de transactions n&amp;rsquo;est plus une option dans vos plans de sauvegarde. Assurez-vous
que ces archives soient stockées sur un espace sécurisé, voire une zone
décentralisée pour qu&amp;rsquo;elles soient accessibles par toutes les instances secondaires
lorsque vous devez déclencher votre &lt;a href="https://fljd.in/2019/12/19/le-jour-ou-tout-bascule">plan de bascule&lt;/a>.&lt;/p>
&lt;p>Pour ceux ayant atteint cette partie de l&amp;rsquo;article, vous ne devriez pas être
trop perdus si je vous annonce que le fichier &lt;code>backup_label&lt;/code> est un composant
d&amp;rsquo;un plus large concept, à savoir : la sauvegarde.&lt;/p>
&lt;blockquote>
&lt;p>Le fichier historique de sauvegarde est un simple fichier texte. Il contient
le label que vous avez attribué à l&amp;rsquo;opération &lt;code>pg_basebackup&lt;/code>, ainsi que les
dates de début, de fin et la liste des segments WAL de la sauvegarde. Si vous
avez utilisé le label pour identifier le fichier de sauvegarde associé, alors
le fichier historique vous permet de savoir quel fichier de sauvegarde vous
devez utiliser pour la restauration.&lt;/p>
&lt;p>Source : &lt;a href="https://docs.postgresql.fr/13/continuous-archiving.html#BACKUP-BASE-BACKUP" target="_blank" rel="noopener">Réaliser une sauvegarde de base&lt;/a>&lt;/p>&lt;/blockquote>
&lt;p>Prenons une instance classique en cours d&amp;rsquo;exécution et réalisons une sauvegarde
avec l&amp;rsquo;outil &lt;a href="https://www.postgresql.org/docs/13/app-pgbasebackup.html" target="_blank" rel="noopener">pg_basebackup&lt;/a> que nous vante la documentation. Observons son
comportement le plus simple avec la génération d&amp;rsquo;une archive au format &lt;code>tar&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">$ pg_basebackup --label=demo --pgdata=backups --format=tar \
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --checkpoint=fast --verbose
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pg_basebackup: initiating base backup, waiting for checkpoint to complete
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pg_basebackup: checkpoint completed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pg_basebackup: write-ahead log start point: 0/16000028 on timeline 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pg_basebackup: starting background WAL receiver
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pg_basebackup: created temporary replication slot &amp;#34;pg_basebackup_15594&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pg_basebackup: write-ahead log end point: 0/16000100
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pg_basebackup: waiting for background process to finish streaming ...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pg_basebackup: syncing data to disk ...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pg_basebackup: renaming backup_manifest.tmp to backup_manifest
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pg_basebackup: base backup completed
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Depuis la version 10, l&amp;rsquo;option &lt;code>--wal-method&lt;/code> est définie
sur &lt;code>stream&lt;/code> par défaut, ce qui indique que tous les journaux de transactions
présents et à venir dans le sous-répertoire &lt;code>pg_wal&lt;/code> de l&amp;rsquo;instance seront
également sauvegardés dans une archive dédiée, notamment grâce à la création
d&amp;rsquo;un slot de réplication temporaire.&lt;/p>
&lt;p>Depuis la version 13, l&amp;rsquo;outil embarque le fichier manifeste dans la sauvegarde
afin de pouvoir contrôler l&amp;rsquo;intégrité de la copie par la commande
&lt;a href="https://fljd.in/2020/11/18/quelques-outils-meconnus/#pg_verifybackup">pg_verifybackup&lt;/a>. Contrôlons le contenu du répertoire de sauvegarde et
recherchons le tant attendu &lt;code>backup_label&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">$ tree backups/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">backups/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── backup_manifest
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── base.tar
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">└── pg_wal.tar
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">$ tar -xf backups/base.tar --to-stdout backup_label
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">START WAL LOCATION: 0/16000028 (file 000000010000000000000016)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CHECKPOINT LOCATION: 0/16000060
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">BACKUP METHOD: streamed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">BACKUP FROM: master
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">START TIME: 2021-01-18 15:22:52 CET
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">LABEL: demo
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">START TIMELINE: 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ce dernier se trouve à la racine de notre archive et joue un rôle très
particulier dans le processus de démarrage &lt;code>startup&lt;/code> puisqu&amp;rsquo;il renseigne le point
de reprise à partir duquel rejouer les journaux. Dans notre exemple, il s&amp;rsquo;agit
de la position &lt;code>0/16000060&lt;/code> présente dans le journal &lt;code>000000010000000000000016&lt;/code>.
En cas d&amp;rsquo;absence du &lt;code>backup_label&lt;/code>, le processus de démarrage consultera à la
place le &lt;a href="https://pgpedia.info/p/pg_control.html" target="_blank" rel="noopener">fichier de contrôle&lt;/a> afin de déterminer le plus récent point de
reprise sans garantie qu&amp;rsquo;il soit le bon.&lt;/p>
&lt;hr>
&lt;h2 id="lheure-de-gloire">L&amp;rsquo;heure de gloire&lt;/h2>
&lt;p>Vous conviendrez que la forme et l&amp;rsquo;intérêt du fichier &lt;code>backup_label&lt;/code> sont
anecdotiques (bien qu&amp;rsquo;essentiels) dans l&amp;rsquo;architecture de sauvegarde avec PostgreSQL.
Il ne s&amp;rsquo;agit que d&amp;rsquo;un fichier texte de quelques lignes, requis exclusivement pour
assurer certains contrôles lors d&amp;rsquo;une restauration.&lt;/p>
&lt;p>Et pourtant, la petite révolution que provoqua la version 8.0 en janvier 2005
avec l&amp;rsquo;archivage continu et la restauration PITR suscita naturellement la
créativité de l&amp;rsquo;équipe de développement au cours des années qui suivirent. Le
fichier &lt;code>backup_label&lt;/code> évolua pour gagner en modularité et en stabilité.&lt;/p>
&lt;p>À l&amp;rsquo;origine, l&amp;rsquo;outil &lt;code>pg_basebackup&lt;/code> n&amp;rsquo;était pas encore disponible et seul l&amp;rsquo;appel
à la méthode &lt;a href="https://pgpedia.info/p/pg_start_backup.html" target="_blank" rel="noopener">pg_start_backup()&lt;/a> permettait de générer le fichier dans lequel
se trouvaient les quatres informations &lt;a href="https://github.com/postgres/postgres/blob/REL8_0_STABLE/src/backend/access/transam/xlog.c#L5411" target="_blank" rel="noopener">suivantes&lt;/a> pour accompagner la
sauvegarde à chaud :&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp"># backend/access/transam/xlog.c
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="nf">fprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;START WAL LOCATION: %X/%X (file %s)&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">startpoint&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">xlogid&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">startpoint&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">xrecoff&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">xlogfilename&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">fprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;CHECKPOINT LOCATION: %X/%X&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">checkpointloc&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">xlogid&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">checkpointloc&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">xrecoff&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">fprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;START TIME: %s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">strfbuf&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">fprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;LABEL: %s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">backupidstr&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Les versions majeures se sont enchaînées avec son lot de corrections ou
d&amp;rsquo;améliorations. Parmi les contributions notables, j&amp;rsquo;ai relevé pour vous :&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://www.postgresql.org/message-id/flat/D960CB61B694CF459DCFB4B0128514C201ED284B%40exadv11.host.magwien.gv.at" target="_blank" rel="noopener">Contribution&lt;/a> de Laurenz Albe (commit &lt;a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=c979a1fefafcc83553bf218c7f2270cad77ea31d" target="_blank" rel="noopener">c979a1fe&lt;/a>)&lt;/p>
&lt;p>Publié avec la version 8.4, le code &lt;code>xlog.c&lt;/code> se voit enrichir d&amp;rsquo;une méthode
interne pour annuler la sauvegarde en cours. L&amp;rsquo;exécution de la commande
&lt;code>pg_ctl stop&lt;/code> en mode &lt;em>fast&lt;/em> renomme le fichier en &lt;code>backup_label.old&lt;/code> ;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.postgresql.org/message-id/flat/20120624213341.GA90986%40mr-paradox.net" target="_blank" rel="noopener">Contribution&lt;/a> de Dave Kerr (commit &lt;a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=0f04fc67f71f7cb29ccedb2e7ddf443b9e52b958" target="_blank" rel="noopener">0f04fc67&lt;/a>)&lt;/p>
&lt;p>Apparue avec la version mineure 9.0.9, la méthode &lt;code>pg_start_backup()&lt;/code> inclut
un appel &lt;code>fsync()&lt;/code> pour forcer l&amp;rsquo;écriture sur disque du fichier &lt;code>backup_label&lt;/code>.
Cette sécurité garantit la consistance d&amp;rsquo;un instantané matériel ;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.postgresql.org/message-id/flat/4E40F710.6000404%40enterprisedb.com" target="_blank" rel="noopener">Contribution&lt;/a> de Heikki Linnakangas (commit &lt;a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=41f9ffd928b6fdcedd685483e777b0fa71ece47c" target="_blank" rel="noopener">41f9ffd9&lt;/a>)&lt;/p>
&lt;p>Proposé en version 9.2, ce patch corrige des comportements anormaux de
restauration à partir de la nouvelle méthode de sauvegarde par flux. Le fichier
&lt;code>backup_label&lt;/code> précise la méthode employée entre &lt;code>pg_start_backup&lt;/code> ou &lt;code>streamed&lt;/code> ;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.postgresql.org/message-id/flat/201108050646.p756kHC5023570%40ccmds32.silk.ntts.co.jp" target="_blank" rel="noopener">Contribution&lt;/a> de Jun Ishizuka et Fujii Masao (commit &lt;a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=8366c7803ec3d0591cf2d1226fea1fee947d56c3" target="_blank" rel="noopener">8366c780&lt;/a>)&lt;/p>
&lt;p>Depuis la version 9.2, la méthode &lt;code>pg_start_backup()&lt;/code> peut être exécutée sur
une instance secondaire. Le rôle de l&amp;rsquo;instance d&amp;rsquo;où provient la sauvegarde est
renseignée dans le fichier &lt;code>backup_label&lt;/code> ;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.postgresql.org/message-id/flat/CAB7nPqRosJNapKVW2QPwkN9%2BypfL4yiR4mcNFZcjxS2c8m%2BVkw%40mail.gmail.com" target="_blank" rel="noopener">Contribution&lt;/a> de Michael Paquier (commit &lt;a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=6271fceb8a4f07dafe9d67dcf7e849b319bb2647" target="_blank" rel="noopener">6271fceb&lt;/a>)&lt;/p>
&lt;p>Ajoutée en version 11, l&amp;rsquo;information &lt;em>timeline&lt;/em> dans le fichier &lt;code>backup_label&lt;/code>
rejoint les précédentes pour comparer sa valeur avec celles des journaux à
rejouer lors d&amp;rsquo;une récupération de données ;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Vous l&amp;rsquo;aurez compris, pendant de nombreuses années, la capacité de faire une
sauvegarde dite consistante, reposait sur les deux méthodes vues précédemment.
La fonction historique &lt;code>pg_start_backup()&lt;/code> fut particulièrement touchée
par d&amp;rsquo;incessantes critiques au sujet d&amp;rsquo;un comportement non souhaité, notamment
son mode « exclusif ».&lt;/p>
&lt;p>Voyons cela ensemble sur une instance récente en version 13 :&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">pg_start_backup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;demo&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">-- pg_start_backup
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- -----------------
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- 0/1D000028
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">$ kill -ABRT $(head -1 data/postmaster.pid)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ cat data/backup_label
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">START WAL LOCATION: 0/1D000028 (file 00000001000000000000001D)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CHECKPOINT LOCATION: 0/1D000060
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">BACKUP METHOD: pg_start_backup
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">BACKUP FROM: master
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">START TIME: 2021-01-18 16:49:57 CET
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">LABEL: demo
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">START TIMELINE: 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Le signal &lt;code>ABRT&lt;/code> interrompt sans préavis le processus &lt;code>postmaster&lt;/code> de l&amp;rsquo;instance
et la routine d&amp;rsquo;arrêt &lt;code>CancelBackup&lt;/code> n&amp;rsquo;est pas appelée pour renommer le fichier
en &lt;code>backup_label.old&lt;/code>. Avec une activité classique de production, les journaux
sont recyclés et archivés à mesure que les transactions s&amp;rsquo;enchaînent. Au démarrage
de l&amp;rsquo;instance, le fichier &lt;code>backup_label&lt;/code> présent dans le répertoire de données
est lu par erreur et n&amp;rsquo;indique plus le bon point de reprise pour la récupération
des données.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">LOG: database system was shut down at 2021-01-18 17:08:43 CET
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">LOG: invalid checkpoint record
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">FATAL: could not locate required checkpoint record
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">HINT: If you are restoring from a backup, touch &amp;#34;data/recovery.signal&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> and add required recovery options.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> If you are not restoring from a backup, try removing the file
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;data/backup_label&amp;#34;.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Be careful: removing &amp;#34;data/backup_label&amp;#34; will result in a corrupt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> cluster if restoring from a backup.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">LOG: startup process (PID 19320) exited with exit code 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">LOG: aborting startup due to startup process failure
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">LOG: database system is shut down
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ce message complet n&amp;rsquo;est apparu qu&amp;rsquo;à partir de la version 12 avec un &lt;a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=c900c15269f0f900d666bd1b0c6df3eff5098678" target="_blank" rel="noopener">avertissement&lt;/a>
plus prononcé dans la documentation au sujet du fichier, faisant suite à de longs
échanges sur la possibilité de se séparer ou non de cette méthode. Dans l&amp;rsquo;un
d&amp;rsquo;eux, on peut lire la remarquable &lt;a href="https://www.postgresql.org/message-id/CA&amp;#43;TgmoaGvpybE=xvJeg9Jc92c-9ikeVz3k-_Hg9=mdG05u=e=g@mail.gmail.com" target="_blank" rel="noopener">intervention&lt;/a> de Robert Haas qui revient
sur le succès de cette fonctionnalité depuis ses débuts et la confusion fréquente
que rencontrent les utilisateurs qui ne comprennent ni la complexité ni les
instructions claires de la documentation.&lt;/p>
&lt;p>À présent, une note y clarifie les choses.&lt;/p>
&lt;blockquote>
&lt;p>Ce type de sauvegarde peut seulement être réalisé sur un serveur primaire et
ne permet pas des sauvegardes concurrentes. De plus, le fichier backup_label
créé sur un serveur primaire peut empêcher le redémarrage de celui-ci en cas
de crash. D&amp;rsquo;un autre côté, la suppression à tord de ce fichier d&amp;rsquo;une sauvegarde
ou d&amp;rsquo;un serveur secondaire est une erreur fréquente qui peut mener à de
sérieuses corruptions de données.&lt;/p>
&lt;p>Source : &lt;a href="https://docs.postgresql.fr/12/continuous-archiving.html#BACKUP-LOWLEVEL-BASE-BACKUP-EXCLUSIVE" target="_blank" rel="noopener">Créer une sauvegarde exclusive de bas niveau&lt;/a>&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;h2 id="place-à-la-relève">Place à la relève&lt;/h2>
&lt;p>Cette limitation était connue de longue date et l&amp;rsquo;équipe de développement
proposa une &lt;a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=7117685461af50f50c03f43e6a622284c8d54694" target="_blank" rel="noopener">alternative&lt;/a> en septembre 2016 avec la sortie de la version 9.6
et l&amp;rsquo;introduction de la sauvegarde dite « concurrente ». Depuis ce jour, la
sauvegarde exclusive est annoncée obsolète par les développeurs et pourrait être
supprimée dans les versions à venir.&lt;/p>
&lt;p>Le fichier &lt;code>backup_label&lt;/code> ne disparaît pas en soi. Ses informations sont toujours
requises pour la restauration PITR mais le fichier n&amp;rsquo;a plus d&amp;rsquo;état transitoire sur
le disque et n&amp;rsquo;est plus écrit dans le répertoire de l&amp;rsquo;instance par la méthode
&lt;code>pg_start_backup()&lt;/code>. En remplacement, l&amp;rsquo;administrateur ou le script de sauvegarde
doit être en capacité d&amp;rsquo;exécuter la commande &lt;code>pg_stop_backup()&lt;/code> dans la même
connexion à l&amp;rsquo;instance pour y récupérer les éléments et reconstruire le fichier
au moment de la restauration.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">pg_start_backup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">label&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;demo&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">exclusive&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">false&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fast&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">true&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">-- pg_start_backup
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- -----------------
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- 0/42000028
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">labelfile&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">pg_stop_backup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">exclusive&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">false&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">-- labelfile
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- ----------------------------------------------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- START WAL LOCATION: 0/42000028 (file 000000010000000000000042)+
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- CHECKPOINT LOCATION: 0/42000060 +
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- BACKUP METHOD: streamed +
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- BACKUP FROM: master +
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- START TIME: 2021-01-18 18:17:16 CET +
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- LABEL: demo +
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- START TIMELINE: 1 +
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Une autre méthode nous permet de retrouver facilement le contenu du fichier,
d&amp;rsquo;autant plus si l&amp;rsquo;archivage est en place sur l&amp;rsquo;instance. En effet, à l&amp;rsquo;annonce
de la fin d&amp;rsquo;une sauvegarde, les éléments précédents sont écrits dans un fichier
d&amp;rsquo;historique &lt;code>.backup&lt;/code> au sein des journaux de transactions et un fichier &lt;code>.ready&lt;/code>
est ajouté dans le répertoire &lt;code>archive_status&lt;/code> à destination du processus
d&amp;rsquo;archivage. Une recherche rapide sur le dépôt des archives plus tard, et nous
sommes en possession du fichier prêt à l&amp;rsquo;emploi pour une restauration.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">$ find archives -type f -not -size 16M
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">archives/000000010000000000000016.00000028.backup
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ grep -iv ^stop archives/000000010000000000000016.00000028.backup
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">START WAL LOCATION: 0/42000028 (file 000000010000000000000042)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CHECKPOINT LOCATION: 0/42000060
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">BACKUP METHOD: streamed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">BACKUP FROM: master
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">START TIME: 2021-01-18 18:17:16 CET
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">LABEL: demo
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">START TIMELINE: 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>La venue d&amp;rsquo;une brique complète pour la sauvegarde concurrente a permis l&amp;rsquo;émergence
de nouvelles solutions de sauvegardes, plus performantes et plus modulaires que
&lt;code>pg_basebackup&lt;/code>. Dans le paysage des outils tiers, vous entendriez peut-être parler
de &lt;a href="https://pgbackrest.org/" target="_blank" rel="noopener">pgBackRest&lt;/a> écrit en C, &lt;a href="https://www.pgbarman.org/" target="_blank" rel="noopener">Barman&lt;/a> écrit en Python ou &lt;a href="https://dalibo.github.io/pitrery/" target="_blank" rel="noopener">pitrery&lt;/a> écrit en Bash.
En outre, ces outils soulagent l&amp;rsquo;administrateur de la rédaction de scripts devenus
trop complexes et loin d&amp;rsquo;être immuable dans les années à venir.&lt;/p>
&lt;hr>
&lt;h2 id="morale-de-lhistoire">Morale de l&amp;rsquo;histoire&lt;/h2>
&lt;p>Au fil des versions, le fichier &lt;code>backup_label&lt;/code> a enduré de nombreuses tempêtes
et rebondissements pour aboutir à une forme plus aboutie de la sauvegarde et de
la restauration physique dans PostgreSQL.&lt;/p>
&lt;p>Si vous êtes responsable de la maintenance d&amp;rsquo;instances, particulièrement dans
un environnement virtualisé, je ne peux que vous recommander de contrôler vos
politiques de sauvegarde et l&amp;rsquo;outillage associé. Il n&amp;rsquo;est pas rare de voir des
hyperviseurs réaliser des instantanées des machines virtuelles avec des appels de
la méthode &lt;code>pg_start_backup()&lt;/code> en mode exclusif.&lt;/p>
&lt;p>Les outils spécialisés cités plus haut peuvent/doivent être étudiés. S&amp;rsquo;ils ne
correspondent pas très bien à vos besoins, il est toujours possible de
bénéficier des mécanismes de la sauvegarde concurrente à l&amp;rsquo;aide d&amp;rsquo;un &lt;a href="https://www.commandprompt.com/blog/postgresql-non-exclusive-base-Backup-bash/" target="_blank" rel="noopener">fichier
temporaire&lt;/a> sous Linux et sa commande &lt;code>mkfifo&lt;/code>.&lt;/p>
&lt;p>La décision de supprimer définitivement la sauvegarde exclusive n&amp;rsquo;est actuellement
plus débattue et a été retirée du &lt;em>backlog&lt;/em> de développement lors du Commitfest
de &lt;a href="https://commitfest.postgresql.org/28/1913/" target="_blank" rel="noopener">juillet 2020&lt;/a>. Lors des derniers échanges, le contributeur David Steele
(auteur de pgBackRest notamment) &lt;a href="https://www.postgresql.org/message-id/d4da3456-06a0-b790-fb07-036d0bd4bf0d%40pgmasters.net" target="_blank" rel="noopener">annonçait&lt;/a> qu&amp;rsquo;une sauvegarde exclusive pourrait
stocker son fichier &lt;code>backup_label&lt;/code> directement en mémoire partagée plutôt que sur
le disque et ainsi corriger sa principale faiblesse :&lt;/p>
&lt;blockquote>
&lt;p>It might be easier/better to just keep the one exclusive slot in shared
memory and store the backup label in it. We only allow one exclusive
backup now so it wouldn&amp;rsquo;t be a loss in functionality.&lt;/p>&lt;/blockquote>
&lt;p>La suite au prochain épisode !&lt;/p></description></item><item><title>Construire une instance standby avec pgBackRest</title><link>https://fljd.in/2019/11/07/construire-une-instance-standby-avec-pgbackrest/</link><pubDate>Thu, 07 Nov 2019 16:00:00 +0200</pubDate><author>Florent Jardin</author><guid>https://fljd.in/2019/11/07/construire-une-instance-standby-avec-pgbackrest/</guid><description>&lt;p>Pour cette démonstration, j&amp;rsquo;utilise le système Debian et dispose de deux instances
en version 12, d&amp;rsquo;un serveur de sauvegarde et du paquet &lt;code>pgbackrest&lt;/code> pour mettre
en place une réplication et observer les nouveautés concernant la &lt;a href="https://paquier.xyz/postgresql-2/postgres-12-recovery-change/" target="_blank" rel="noopener">disparition&lt;/a>
du fichier &lt;code>recovery.conf&lt;/code>.&lt;/p>
&lt;p>Pour faciliter le transfert des WAL et des sauvegardes PITR, j&amp;rsquo;ajoute un compte
utilisateur &lt;code>pgbr&lt;/code> sur le serveur de sauvegarde, accessible à partir des deux
instances avec un partage de clé SSH. &lt;em>(Conseil : toujours externaliser les
sauvegardes de bases de données sur un système et un stockage indépendant de
l&amp;rsquo;infrastructure de production PostgreSQL…)&lt;/em>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">sudo useradd -s /bin/bash -md /etc/pgbackrest pgbr
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo mv /etc/pgbackrest.conf /etc/pgbackrest/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo chown pgbr: /etc/pgbackrest/pgbackrest.conf &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> /var/log/pgbackrest /var/lib/pgbackrest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>La réplication par flux (&lt;em>streaming&lt;/em>) est assurée par un compte dédié nommé
&lt;code>streamer&lt;/code>, autorisé à se connecter sur les instances PostgreSQL du sous-réseau
grâce à l&amp;rsquo;ajout d&amp;rsquo;une entrée dans le fichier &lt;code>pg_hba.conf&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">sudo -u postgres createuser --replication --pwprompt streamer
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># pg_hba.conf&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Allow replication connections from trusted subnet, by a user with the&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># replication privilege.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">host replication streamer 10.1.0.0/28 md5&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;em>Le fichier &lt;code>.pgpass&lt;/code> est déposé sur chaque serveur pour le compte &lt;code>postgres&lt;/code>,
afin d&amp;rsquo;assurer la connexion du compte &lt;code>streamer&lt;/code> sans saisie de mot de passe.&lt;/em>&lt;/p>
&lt;hr>
&lt;p>Dans ce scénario, les archives générées par l&amp;rsquo;instance primaire seront déplacées
sur le serveur de sauvegarde et l&amp;rsquo;instance standby les consultera au besoin. La
planification des sauvegardes sera sous la responsabilité de l&amp;rsquo;utilisateur &lt;code>pgbr&lt;/code>
avec une administration distante. La configuration fine se découpe dans les
fichiers suivants.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># /etc/pgbackrest/bkp1.conf&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">[lab]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">pg1-host&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">lab1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">pg2-host&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">lab2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">pg1-host-user&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">postgres&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">pg2-host-user&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">postgres&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">pg1-path&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">/var/lib/postgresql/12/lab1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">pg2-path&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">/var/lib/postgresql/12/lab2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">pg1-host-config&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">/etc/pgbackrest/lab1.conf&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">pg2-host-config&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">/etc/pgbackrest/lab2.conf&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">[global]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">start-fast&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">y&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">log-level-console&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">info&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">repo1-retention-full&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">repo1-path&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">/var/lib/pgbackrest&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># /etc/pgbackrest/lab1.conf&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">[lab]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">pg1-path&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">/var/lib/postgresql/12/lab1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">[global]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">repo1-host&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">bkp1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">repo1-host-user&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">pgbr&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># /etc/pgbackrest/lab2.conf&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">[lab]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">pg1-path&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">/var/lib/postgresql/12/lab2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">recovery-option&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">recovery_target_timeline=latest&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">recovery-option&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">primary_conninfo=host=lab1 port=5432 user=streamer&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">[global]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">repo1-host&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">bkp1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">repo1-host-user&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">pgbr&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Avant de pouvoir créer la stanza, il est nécessaire de démarrer l&amp;rsquo;instance secondaire
en mode &lt;code>standby&lt;/code> ; il suffit de positionner un fichier &lt;code>standby.signal&lt;/code> dans
le répertoire de données et de redémarrer l&amp;rsquo;instance :&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">sudo pg_ctlcluster stop &lt;span class="m">12&lt;/span> lab2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo -u postgres touch /var/lib/postgresql/12/lab1/standby.signal
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo pg_ctlcluster start &lt;span class="m">12&lt;/span> lab2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>À partir de ce moment, et même si les deux instances ne partagent pas les mêmes
données, je peux créer la stanza avec l&amp;rsquo;outil &lt;code>pgbackrest&lt;/code> sur mon serveur de
sauvegarde avec l&amp;rsquo;utilisateur dédié.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">sudo -u pgbr pgbackrest stanza-create &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --stanza&lt;span class="o">=&lt;/span>lab --config&lt;span class="o">=&lt;/span>/etc/pgbackrest/bkp1.conf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Dès ce moment, mon instance, consciente de l&amp;rsquo;espace de stockage distant, peut
envoyer ses archives de WAL &lt;em>via&lt;/em> la commande &lt;code>archive-push&lt;/code> de &lt;code>pgbackrest&lt;/code>.
Un redémarrage est requis pour activer le mode archive.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">ALTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SYSTEM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">archive_mode&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">on&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ALTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SYSTEM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">archive_command&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;pgbackrest archive-push %p --stanza=lab --config=/etc/pgbackrest/lab1.conf&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Et pour finir, une première sauvegarde complète peut être lancée sur le serveur
de sauvegarde pour assurer la construction de l&amp;rsquo;instance standby.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">sudo -u pgbr pgbackrest backup --stanza&lt;span class="o">=&lt;/span>lab --config&lt;span class="o">=&lt;/span>/etc/pgbackrest/bkp1.conf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo -u pgbr pgbackrest info
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># stanza: lab&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># status: ok&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># cipher: none&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># db (current)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># wal archive min/max (12-1): 000000010000000000000008/000000010000000000000008&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># full backup: 20191107-103443F&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># timestamp start/stop: 2019-11-07 10:34:43 / 2019-11-07 10:35:09&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># wal start/stop: 000000010000000000000008 / 000000010000000000000008&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># database size: 23.5MB, backup size: 23.5MB&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># repository size: 2.8MB, repository backup size: 2.8MB&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>La sauvegarde de l&amp;rsquo;instance primaire peut être restaurée sur la seconde instance
avec les options &lt;code>--delta&lt;/code> et &lt;code>--type=standby&lt;/code> pour écraser les fichiers erronés
et ajouter le descripteur &lt;code>standby.signal&lt;/code> dans le répertoire de données. pgBackRest
se charge de configurer les options de réplication dans le fichier
&lt;code>postgresql.auto.conf&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">sudo pg_ctlcluster stop &lt;span class="m">12&lt;/span> lab2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo -u postgres pgbackrest restore --stanza&lt;span class="o">=&lt;/span>lab &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --delta --type&lt;span class="o">=&lt;/span>standby --config&lt;span class="o">=&lt;/span>/etc/pgbackrest/lab2.conf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo pg_ctlcluster start &lt;span class="m">12&lt;/span> lab2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Tadaa ! Une connexion est alors établie entre les deux nœuds et l&amp;rsquo;on constate
que l&amp;rsquo;utilisateur &lt;code>streamer&lt;/code> rejoue en asynchrone les transactions de l&amp;rsquo;instance
primaire vers l&amp;rsquo;instance standby.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">pg_stat_replication&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">-- -[ RECORD 1 ]----+------------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- pid | 8893
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- usesysid | 16384
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- usename | streamer
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- application_name | 12/lab2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- client_addr | 10.1.0.1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- client_hostname |
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- client_port | 38820
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- backend_start | 2019-11-07 10:50:22.424464+00
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- backend_xmin |
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- state | streaming
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- sent_lsn | 0/A000060
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- write_lsn | 0/A000060
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- flush_lsn | 0/A000060
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- replay_lsn | 0/A000060
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- write_lag | 00:00:00.001095
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- flush_lag | 00:00:00.004415
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- replay_lag | 00:00:00.004696
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- sync_priority | 0
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- sync_state | async
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- reply_time | 2019-11-07 12:39:59.595595+00
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="message">&lt;p>Pour la rédaction de cet article, je n&amp;rsquo;ai pas véritablement utilisé trois serveurs,
mais bien un seul en réalité. L&amp;rsquo;astuce pour faire tourner deux instances sur le
même port 5432 consiste à ajouter des IP virtuelles sur l&amp;rsquo;interface du serveur
et de faire résoudre les noms de machines par le fichier &lt;code>/etc/hosts&lt;/code> local.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">sudo ip add add 10.1.0.1/28 dev ens6
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo ip add add 10.1.0.2/28 dev ens6
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo ip add add 10.1.0.3/28 dev ens6
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Les instances doivent ensuite être installées/configurées avec les bons paramètres
&lt;code>listen_addresses&lt;/code> et &lt;code>unix_socket_directories&lt;/code> comme suivent :&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">sudo apt-get install -y postgresql-common
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo vim /etc/postgresql-common/createcluster.conf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo apt-get install -y postgresql-12
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo -u postgres mkdir -p /var/run/postgresql/lab{1,2}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo pg_createcluster 12 lab1 \
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --pgoption listen_addresses=&amp;#39;10.1.0.1&amp;#39; --pgoption port=5432 \
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --pgoption unix_socket_directories=/var/run/postgresql/lab1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo pg_createcluster 12 lab2 \
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --pgoption listen_addresses=&amp;#39;10.1.0.2&amp;#39; --pgoption port=5432 \
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --pgoption unix_socket_directories=/var/run/postgresql/lab2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo pg_ctlcluster 12 lab1 start
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo pg_ctlcluster 12 lab2 start
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Quelques ajustements de droits sur le répertoire &lt;code>/tmp/pgbackrest&lt;/code> pour les
fichiers de verrous (paramètre &lt;code>--lock-path&lt;/code>) et le tour est joué !&lt;/p>
&lt;/div></description></item></channel></rss>