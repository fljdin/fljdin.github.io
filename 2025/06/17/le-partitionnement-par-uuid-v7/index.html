<!doctype html><html lang=fr><head><title>Le partitionnement par UUID v7</title><link rel=stylesheet href=https://fljd.in/css/main.min.css><link rel=apple-touch-icon sizes=180x180 href=/ico/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/ico/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/ico/favicon-16x16.png><link rel=manifest href=/ico/site.webmanifest><meta name=fediverse:creator content="@fljdin@mastodon.tedomum.net"><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=UTF-8></head><body><div class="container content"><header class=homepage><h3 class=homepage-title><a href=/ title="Florent Jardin">Florent Jardin</a>
<small><a href=/index.xml><svg class="svg-icon"><use xlink:href="https://fljd.in/img/social-icons.svg#rss"/></svg></a>
<a href=https://mastodon.tedomum.net/@fljdin rel=me><svg class="svg-icon"><use xlink:href="https://fljd.in/img/social-icons.svg#mastodon"/></svg></a>
<a href=https://github.com/fljdin><svg class="svg-icon"><use xlink:href="https://fljd.in/img/social-icons.svg#github"/></svg></a>
<a href=https://www.linkedin.com/in/florent-jardin><svg class="svg-icon"><use xlink:href="https://fljd.in/img/social-icons.svg#linkedin"/></svg></a>
&nbsp;&nbsp;<a href=/conferences>Conférences</a>&nbsp;&nbsp;<a href=/archives>Archives</a>&nbsp;&nbsp;<a href=/a-propos>À propos</a></small></h3></header><main><article class=post><h1 class=post-title>Le partitionnement par UUID v7</a></h1><p class=post-date><time datetime=2025-06-17>17 juin 2025</time>
- 10 minutes de lecture</p><p>Au dernier PG Day 2025, j’ai pris la parole pour présenter une méthode de
conception que je juge mature et astucieuse : le partitionnement temporel
avec le type UUID et sa version 7.</p><p>Le support de présentation est disponible à cette <a href=/documents/pgdayfr-2025-lightning-talk-partitionnement-uuidv7.pdf>adresse</a> et je reprendrais
dans cet article, les exemples en guise de démonstration. Je vous propose de
passer en détail ce que j’ai pu y dire, et ne pas y dire faute de temps.
Également, je vous invite à lire ou redécouvrir mes recherches sur le
<a href=/2021/04/23/le-partitionnement-par-hachage/>partitionnement par hachage</a>.</p><hr><h2 id=explorer-les-limites>Explorer les limites</h2><p>En première lecture de la documentation, nous pouvons prendre conscience que le
choix de la clé de partitionnement est crucial pour parvenir au meilleur
compromis stockage/performance. Parmi les contraintes qui s’imposent à nous,
l’une d’entre elles est particulièrement fondamentale :</p><blockquote><p>Pour créer une contrainte d&rsquo;unicité ou une clé primaire sur une table
partitionnée, la clé de partitionnement ne doit pas inclure des expressions ou
des appels de fonction, et les colonnes de la contrainte doivent inclure toutes
les colonnes de la clé de partitionnement. Cette limitation existe parce que les
index individuels créant la contrainte peuvent seulement forcer l&rsquo;unicité sur
leur propre partition ; de ce fait, la structure même de la partition doit
garantir qu&rsquo;il n&rsquo;existe pas de duplicats dans les différentes partitions.</p><p>Documentation : <a href=https://www.postgresql.org/docs/current/ddl-partitioning.html#DDL-PARTITIONING-DECLARATIVE-LIMITATIONS target=_blank rel=noopener>https://www.postgresql.org/docs/current/ddl-partitioning.html</a></p></blockquote><p>En résumé, si nous souhaitons une contrainte de clé primaire sur notre table
partitionnée, il nous faut y inclure la colonne présente dans la clé de
partitionnement.</p><p>Voyons par l’exemple l’application de cette règle. Un des nombreux cas concernés
par cette limitation est le partitionnement par date, à des fins de purges ou
d’archivage. Une contrainte de clé primaire est requise pour identifier chaque
ligne et un champ <code>timestamp</code> est utilisé pour catégoriser les lignes selon leur
date de création.</p><p><img src=/img/fr/2025-06-17-partitionnement-uuidv7-01.png alt></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>foo</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>id</span><span class=w> </span><span class=nb>bigint</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>name</span><span class=w> </span><span class=nb>varchar</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>created_at</span><span class=w> </span><span class=k>timestamp</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=n>PARTITION</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>RANGE</span><span class=w> </span><span class=p>(</span><span class=n>created_at</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- CREATE TABLE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>foo</span><span class=w> </span><span class=k>ADD</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=n>id</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- ERROR:   unique constraint on partitioned table must include all
</span></span></span><span class=line><span class=cl><span class=c1>--          partitioning columns
</span></span></span><span class=line><span class=cl><span class=c1>-- DETAIL:  PRIMARY KEY constraint on table &#34;foo&#34; lacks column &#34;created_at&#34;
</span></span></span><span class=line><span class=cl><span class=c1>--          which is part of the partition key.
</span></span></span></code></pre></div><p>Pour respecter l’unicité entre toutes les partitions, PostgreSQL se simplifie la
tâche en renforçant la contrainte au moment de la distribution des lignes dans
les partitions. Ainsi, chaque partition dispose d’un index unique pour le
respect de la contrainte d’identité, sans se soucier d’un risque de collision
entre deux lignes de partitions différentes.</p><p>Reprenons notre exemple pour y entrevoir les dérives qu’apporte ce choix de
modélisation. Ici, nous respecterons à la lettre ce que PostgreSQL nous impose,
à savoir : inclure la colonne <code>created_at</code> dans la contrainte de clé primaire.</p><p><img src=/img/fr/2025-06-17-partitionnement-uuidv7-02.png alt></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>foo</span><span class=w> </span><span class=k>ADD</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>created_at</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- ALTER TABLE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>foo_p202506</span><span class=w> </span><span class=n>PARTITION</span><span class=w> </span><span class=k>OF</span><span class=w> </span><span class=n>foo</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>FOR</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=p>(</span><span class=s1>&#39;2025-06-01&#39;</span><span class=p>)</span><span class=w> </span><span class=k>TO</span><span class=w> </span><span class=p>(</span><span class=s1>&#39;2025-07-01&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- CREATE TABLE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>foo_default</span><span class=w> </span><span class=n>PARTITION</span><span class=w> </span><span class=k>OF</span><span class=w> </span><span class=n>foo</span><span class=w> </span><span class=k>DEFAULT</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- CREATE TABLE
</span></span></span></code></pre></div><p>Avec ce choix, il devient possible d’insérer deux valeurs <code>id</code> identiques, pour
peu que leurs dates de création soient différentes. L’identité n’est donc plus
un simple numéro, mais un couple <code>id, timestamp</code> à questionner systématiquement
lors d’une consultation avec la clause <code>WHERE</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>foo</span><span class=w> </span><span class=p>(</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>created_at</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;2025-06-04&#39;</span><span class=p>),</span><span class=w> </span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;2024-01-01&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- INSERT 0 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>tableoid</span><span class=p>::</span><span class=n>regclass</span><span class=w> </span><span class=n>partname</span><span class=p>,</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>created_at</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>foo</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>--   partname   | id |     created_at
</span></span></span><span class=line><span class=cl><span class=c1>-- -------------+----+---------------------
</span></span></span><span class=line><span class=cl><span class=c1>--  foo_p202506 |  1 | 2025-06-04 00:00:00
</span></span></span><span class=line><span class=cl><span class=c1>--  foo_default |  1 | 2024-01-01 00:00:00
</span></span></span></code></pre></div><p>Les choses empirent lorsqu’une relation de clé étrangère s’immisce dans le
casse-tête de la modélisation. En effet, le maintien de l’identité composite
d’une ligne se révèle acrobatique, lors de la rédaction des requêtes SQL
d’insertion et de jointure.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>bar</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>id</span><span class=w> </span><span class=nb>bigint</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>data</span><span class=w> </span><span class=nb>text</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>created_at</span><span class=w> </span><span class=k>timestamp</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>foo_id</span><span class=w> </span><span class=nb>bigint</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>foo_created_id</span><span class=w> </span><span class=k>timestamp</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>FOREIGN</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=n>foo_id</span><span class=p>,</span><span class=w> </span><span class=n>foo_created_id</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>REFERENCES</span><span class=w> </span><span class=n>foo</span><span class=w> </span><span class=p>(</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>created_at</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- CREATE TABLE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WITH</span><span class=w> </span><span class=n>foo_insert</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>foo</span><span class=w> </span><span class=p>(</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>created_at</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;foo&#39;</span><span class=p>,</span><span class=w> </span><span class=n>clock_timestamp</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>RETURNING</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>created_at</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>bar</span><span class=w> </span><span class=p>(</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=k>data</span><span class=p>,</span><span class=w> </span><span class=n>created_at</span><span class=p>,</span><span class=w> </span><span class=n>foo_id</span><span class=p>,</span><span class=w> </span><span class=n>foo_created_id</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>SELECT</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;bar&#39;</span><span class=p>,</span><span class=w> </span><span class=n>clock_timestamp</span><span class=p>(),</span><span class=w> </span><span class=n>f</span><span class=p>.</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>f</span><span class=p>.</span><span class=n>created_at</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>FROM</span><span class=w> </span><span class=n>foo_insert</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>f</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- INSERT 0 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>bar</span><span class=p>.</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>bar</span><span class=p>.</span><span class=n>created_at</span><span class=p>,</span><span class=w> </span><span class=k>data</span><span class=p>,</span><span class=w> </span><span class=n>foo</span><span class=p>.</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>foo</span><span class=p>.</span><span class=n>name</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>FROM</span><span class=w> </span><span class=n>bar</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>JOIN</span><span class=w> </span><span class=n>foo</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>ON</span><span class=w> </span><span class=n>foo</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>bar</span><span class=p>.</span><span class=n>foo_id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>AND</span><span class=w> </span><span class=n>foo</span><span class=p>.</span><span class=n>created_at</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>bar</span><span class=p>.</span><span class=n>foo_created_id</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>--  id |         created_at         | data | id | name
</span></span></span><span class=line><span class=cl><span class=c1>-- ----+----------------------------+------+----+------
</span></span></span><span class=line><span class=cl><span class=c1>--   1 | 2025-06-16 20:12:02.101194 | bar  |  2 | foo
</span></span></span></code></pre></div><p>L’exercice devient catastrophique lorsque la seconde table requiert d’être
partitionnée à son tour, et où le risque de mauvaise rédaction des requêtes
augmente selon le degré de connaissance du modèle par les équipes de
développement. Nous retiendrons que cette pratique n’a pas cours et se conclut
fréquemment par un retour arrière.</p><p><img src=/img/fr/2025-06-17-partitionnement-uuidv7-03.png alt></p><hr><h2 id=la-version-7-du-type-uuid>La version 7 du type UUID</h2><p>La <a href=https://www.rfc-editor.org/rfc/rfc9562 target=_blank rel=noopener>RFC 9562</a> voit le jour en mai 2024 et propose d’étendre le type de
données UUID de trois nouvelles versions (6, 7 et 8). Un UUID (ou <em>Universally
Unique IDentifier</em>) est une donnée encodée sur 16 octets, garantissant une
unicité à travers le temps (son heure de génération) et l’espace (son serveur de
génération). Les UUID sont redoutables dans un contexte de systèmes distribués
où chaque participant peut créer de la donnée (une ligne) sans risque de collision
avec une autre donnée.</p><p>La structure d’un UUID v7 se voit doté d’un <em>timestamp UNIX</em> d’une précision à la
milliseconde, encodé dans les 48 premiers bits de sa valeur. Cette version est
un compromis entre la randomicité et la praticité. Les bénéfices vous paraîtront
limpides à l’issue de cet article.</p><p><img src=/img/fr/2025-06-17-partitionnement-uuidv7-04.png alt></p><p>La version 7 était unanimement attendue, car elle apporte une réponse bien plus
appropriée pour l’indexation dans les bases de données, offrant à la fois une
unicité et une sortabilité pour les champs. Auparavant, l’indexation sur une
donnée UUID v4 était désastreuse pour le cache et la fragmentation. Avec cet
accroissement monotone des UUID au fil du temps, la gestion interne d’un index
B-Tree se voit naturellement facilitée avec un équilibrage moins fréquent et une
prédictibilité dans ses performances.</p><p>Une <a href=https://dev.to/umangsinha12/postgresql-uuid-performance-benchmarking-random-v4-and-time-based-v7-uuids-n9b target=_blank rel=noopener>publication récente</a> annonçait des gains significatifs entre la version
4 et la version 7, sur les insertions, les consultations par index ainsi que sur
l’espace occupé par les tables et les index. De quoi se réconcilier avec le type
UUID !</p><table><thead><tr><th>Metric</th><th style=text-align:right>UUIDv4</th><th style=text-align:right>UUIDv7</th><th style=text-align:right>Improvement</th></tr></thead><tbody><tr><td>Insert Time (10M rows)</td><td style=text-align:right>5 min 35 sec</td><td style=text-align:right>3 min 38 sec</td><td style=text-align:right>~35% faster</td></tr><tr><td>Table Size</td><td style=text-align:right>3618 MB</td><td style=text-align:right>3443 MB</td><td style=text-align:right>~5% smaller</td></tr><tr><td>Index Size</td><td style=text-align:right>776 MB</td><td style=text-align:right>602 MB</td><td style=text-align:right>~22% smaller</td></tr><tr><td>Point Lookup Latency</td><td style=text-align:right>0.167 ms</td><td style=text-align:right>0.038 ms</td><td style=text-align:right>~4x faster</td></tr><tr><td>Range Scan Latency</td><td style=text-align:right>8.284 ms</td><td style=text-align:right>3.791 ms</td><td style=text-align:right>~2x faster</td></tr></tbody></table><p>La communauté de développement de PostgreSQL a suivi l’actualité de cette RFC,
en proposant un <a href="https://www.postgresql.org/message-id/CAAhFRxitJv=yoGnXUgeLB_O+M7J2BJAmb5jqAT9gZ3bij3uLDA@mail.gmail.com" target=_blank rel=noopener>premier patch</a> en février 2023 alors que le brouillon de
l’<em>Internet Engineering Task Force</em> (IETF) venait d’être publié. C’est lors du
<a href=https://commitfest.postgresql.org/patch/4388/ target=_blank rel=noopener>CommitFest</a> de janvier 2025 que le sujet est clôturé avec l’ajout dans le
commit <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=78c5e141e9c139fc2ff36a220334e4aa25e1b0eb" target=_blank rel=noopener>78c5e14</a> de deux méthodes pour la version 18, annoncée à l’automne
prochain.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>author    Masahiko Sawada &lt;msawada@postgresql.org&gt;
</span></span><span class=line><span class=cl>          Wed, 11 Dec 2024 23:54:41 +0000 (15:54 -0800)
</span></span><span class=line><span class=cl>committer Masahiko Sawada &lt;msawada@postgresql.org&gt;
</span></span><span class=line><span class=cl>          Wed, 11 Dec 2024 23:54:41 +0000 (15:54 -0800)
</span></span><span class=line><span class=cl>Add UUID version 7 generation function.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>This commit introduces the uuidv7() SQL function, which generates UUID
</span></span><span class=line><span class=cl>version 7 as specified in RFC 9652. UUIDv7 combines a Unix timestamp
</span></span><span class=line><span class=cl>in milliseconds and random bits, offering both uniqueness and
</span></span><span class=line><span class=cl>sortability.
</span></span><span class=line><span class=cl>This commit also expands the uuid_extract_timestamp() function to
</span></span><span class=line><span class=cl>support UUID version 7.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Additionally, an alias uuidv4() is added for the existing
</span></span><span class=line><span class=cl>gen_random_uuid() SQL function to maintain consistency.
</span></span></code></pre></div><p>Vous me voyez venir ? À l’aide de cette nouvelle RFC, il devient possible de
disposer d’une colonne d’identité contenant une valeur temporelle et qui devient
<em>de facto</em>, une candidate idéale pour la clé de partitionnement. Le tout sans
surcoût pour le stockage, car chaque champ UUID consommera 16 octets, autant
qu’un <code>bigint</code> (8 octets) et un <code>timestamp</code> (8 octets) réunis !</p><p><img src=/img/fr/2025-06-partitionnement-uuidv7-05.png alt></p><hr><h2 id=partitionner-par-uuid-v7>Partitionner par UUID v7</h2><p>L’idée originale me vient d’un <a href=https://postgresql.verite.pro/blog/2024/07/15/uuid-v7-pure-sql.html#partitioning-by-uuid-v7 target=_blank rel=noopener>article</a> de Daniel Vérité, lu l’été dernier,
alors même que la RFC venait de sortir, mais que le patch dans PostgreSQL était
bloqué par la période de gel avant la sortie de la version 17. Il était question
de pouvoir implémenter ses propres méthodes en PL/pgSQL sur les versions en
vigueur, sans attendre la version 18.</p><p>La création de la table <code>foo</code> se réalise ainsi :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>foo</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>id</span><span class=w> </span><span class=n>uuid</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=n>uuidv7</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>name</span><span class=w> </span><span class=nb>varchar</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=n>PARTITION</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>RANGE</span><span class=w> </span><span class=p>(</span><span class=n>id</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- CREATE TABLE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>foo_p202506</span><span class=w> </span><span class=n>PARTITION</span><span class=w> </span><span class=k>OF</span><span class=w> </span><span class=n>foo</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>FOR</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=p>(</span><span class=n>uuidv7_boundary</span><span class=p>(</span><span class=s1>&#39;2025-06-01&#39;</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>               </span><span class=k>TO</span><span class=w> </span><span class=p>(</span><span class=n>uuidv7_boundary</span><span class=p>(</span><span class=s1>&#39;2025-07-01&#39;</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- CREATE TABLE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>foo_default</span><span class=w> </span><span class=n>PARTITION</span><span class=w> </span><span class=k>OF</span><span class=w> </span><span class=n>foo</span><span class=w> </span><span class=k>DEFAULT</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- CREATE TABLE
</span></span></span></code></pre></div><p>La méthode <code>uuidv7_boundary</code> est inédite et n’a pas d’équivalent dans les
versions à venir de PostgreSQL, bien qu’elle mériterait amplement sa place. Sa
définition est disponible sur le dépôt <a href=https://github.com/dverite/postgres-uuidv7-sql/blob/main/sql/uuidv7-sql--1.0.sql#L63 target=_blank rel=noopener>dverite/postgres-uuidv7-sql</a>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>FUNCTION</span><span class=w> </span><span class=n>uuidv7_boundary</span><span class=p>(</span><span class=n>timestamptz</span><span class=p>)</span><span class=w> </span><span class=k>RETURNS</span><span class=w> </span><span class=n>uuid</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>AS</span><span class=w> </span><span class=err>$$</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=cm>/* uuid fields: version=0b0111, variant=0b10 */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>select</span><span class=w> </span><span class=n>encode</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>overlay</span><span class=p>(</span><span class=s1>&#39;\x00000000000070008000000000000000&#39;</span><span class=p>::</span><span class=n>bytea</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>placing</span><span class=w> </span><span class=k>substring</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>int8send</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=n>floor</span><span class=p>(</span><span class=k>extract</span><span class=p>(</span><span class=n>epoch</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=err>$</span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mi>1000</span><span class=p>)::</span><span class=nb>bigint</span><span class=p>)</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=mi>3</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>from</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=mi>6</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s1>&#39;hex&#39;</span><span class=p>)::</span><span class=n>uuid</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>$$</span><span class=w> </span><span class=k>LANGUAGE</span><span class=w> </span><span class=k>sql</span><span class=w> </span><span class=k>stable</span><span class=w> </span><span class=k>strict</span><span class=w> </span><span class=n>parallel</span><span class=w> </span><span class=n>safe</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>Grâce à cette fonction, il est possible d’obtenir les bornes d’une partition en
ne conservant que la donnée temporelle d’un UUID et en remplissant le reste par
des zéros (et quelques bits fixes). Pour la table <code>foo</code>, on se retrouve dès lors
avec la partition qui respecte les valeurs comprises entre juin et juillet.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>                  Partitioned table &#34;public.foo&#34;
</span></span><span class=line><span class=cl> Column |       Type        | Collation | Nullable | Default
</span></span><span class=line><span class=cl>--------+-------------------+-----------+----------+----------
</span></span><span class=line><span class=cl> id     | uuid              |           | not null | uuidv7()
</span></span><span class=line><span class=cl> name   | character varying |           |          |
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Partition key: RANGE (id)
</span></span><span class=line><span class=cl>Indexes:
</span></span><span class=line><span class=cl>    &#34;foo_pkey&#34; PRIMARY KEY, btree (id)
</span></span><span class=line><span class=cl>Partitions: foo_p202506 FOR VALUES
</span></span><span class=line><span class=cl>              FROM (&#39;0197285b-e300-7000-8000-000000000000&#39;)
</span></span><span class=line><span class=cl>                TO (&#39;0197c2da-ab00-7000-8000-000000000000&#39;),
</span></span><span class=line><span class=cl>            foo_default DEFAULT
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>foo</span><span class=w> </span><span class=p>(</span><span class=n>name</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=s1>&#39;foo&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- INSERT 0 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>tableoid</span><span class=p>::</span><span class=n>regclass</span><span class=w> </span><span class=n>partname</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>uuid_extract_timestamp</span><span class=p>(</span><span class=n>id</span><span class=p>)</span><span class=w> </span><span class=n>created_at</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>FROM</span><span class=w> </span><span class=n>foo</span><span class=w> </span><span class=err>\</span><span class=n>gx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- -[ RECORD 1 ]------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1>-- partname   | foo_p202506
</span></span></span><span class=line><span class=cl><span class=c1>-- id         | 01977a44-364a-752a-b62e-c026ac2f930d
</span></span></span><span class=line><span class=cl><span class=c1>-- name       | foo
</span></span></span><span class=line><span class=cl><span class=c1>-- created_at | 2025-06-16 21:43:00.17+02
</span></span></span></code></pre></div><hr><h2 id=une-pratique-en-bonne-voie>Une pratique en bonne voie</h2><p>Au cours de ma prise de parole, le temps m’avait manqué pour conclure. Les
adeptes de l’extension <a href=https://github.com/pgpartman/pg_partman target=_blank rel=noopener>pg_partman</a> ne seront pas complètement réjouis
d’apprendre que le support du partitionnement automatique pour une colonne de
type UUID est partiellement implémenté.</p><p>La gestion de types <code>text</code> et <code>uuid</code> a été <a href=https://github.com/pgpartman/pg_partman/pull/683 target=_blank rel=noopener>apportée</a> en novembre 2024,
permettant ce genre de magie pour provisionner un certain nombre de partitions.
Les fonctions <code>partman.uuid7_time_encoder</code> et <code>partman.uuid7_time_decoder</code> sont
équivalentes respectivement aux fonctions précédentes <code>uuidv7_boundary</code> et
<code>uuid_extract_timestamp</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>foo</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>id</span><span class=w> </span><span class=n>uuid</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=n>uuidv7</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>name</span><span class=w> </span><span class=nb>varchar</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=n>PARTITION</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>RANGE</span><span class=w> </span><span class=p>(</span><span class=n>id</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- CREATE TABLE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>partman</span><span class=p>.</span><span class=n>create_parent</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>p_parent_table</span><span class=w> </span><span class=p>:</span><span class=o>=</span><span class=w> </span><span class=s1>&#39;public.foo&#39;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>p_control</span><span class=w> </span><span class=p>:</span><span class=o>=</span><span class=w> </span><span class=s1>&#39;id&#39;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>p_interval</span><span class=w> </span><span class=p>:</span><span class=o>=</span><span class=w> </span><span class=s1>&#39;1 month&#39;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>p_time_encoder</span><span class=w> </span><span class=p>:</span><span class=o>=</span><span class=w> </span><span class=s1>&#39;partman.uuid7_time_encoder&#39;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>p_time_decoder</span><span class=w> </span><span class=p>:</span><span class=o>=</span><span class=w> </span><span class=s1>&#39;partman.uuid7_time_decoder&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>--  create_parent
</span></span></span><span class=line><span class=cl><span class=c1>-- ---------------
</span></span></span><span class=line><span class=cl><span class=c1>--  t
</span></span></span></code></pre></div><p>Cependant, le déplacement automatique des lignes de la partition <code>default</code> vers
une autre au cours de la maintenance par <code>partition_data_time()</code> provoque encore
une erreur à l’heure de la rédaction de cet article. La <a href=https://github.com/pgpartman/pg_partman/pull/730 target=_blank rel=noopener>PR 739</a>, proposée
en janvier dernier, tente de corriger en grande partie les angles morts des
travaux engagés.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>partman</span><span class=p>.</span><span class=n>partition_data_time</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>p_parent_table</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s1>&#39;public.foo&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- ERROR:  Cannot run on partition set without time
</span></span></span><span class=line><span class=cl><span class=c1>--         based control column or epoch flag set with
</span></span></span><span class=line><span class=cl><span class=c1>--         an id column. Found control: uuid, epoch: none
</span></span></span><span class=line><span class=cl><span class=c1>-- CONTEXT:  PL/pgSQL function partman.partition_data_time()
</span></span></span><span class=line><span class=cl><span class=c1>--           line 63 at RAISE
</span></span></span></code></pre></div><hr><h2 id=le-mot-de-la-fin>Le mot de la fin</h2><p>Les articles que j’ai énoncés précédemment me conforte dans l’idée que le type
UUID dans sa version 7 est une belle opportunité pour l’adoption de PostgreSQL,
notamment pour ce cas d’usage du partitionnement par date.</p><p>L’accueil que cette rapide présentation a reçu m’a fait également l’effet d’un
appel d’air par l’audience, voyant dans l’UUID un moyen de pousser les limites
du moteur de base de données relationnel et open-source le plus avancé au monde.</p></article><aside class=related><h3>Suggestion d'articles</h3><ul class=related-posts><li><a href=https://fljd.in/2024/11/25/substituer-une-variable-dans-un-script-sql/>Substituer une variable dans un script SQL
<small><time datetime=2024-11-25>25 nov 2024</time></small></a></li><li><a href=https://fljd.in/2024/09/19/les-types-hierarchiques/>Les types hiérarchiques
<small><time datetime=2024-09-19>19 sept 2024</time></small></a></li><li><a href=https://fljd.in/2024/05/28/un-assistant-pour-copier-les-donnees-distantes/>Un assistant pour copier les données distantes
<small><time datetime=2024-05-28>28 mai 2024</time></small></a></li></ul></aside></main><footer class=footer><small>&copy; 2019-<time datetime=2025-10-08>2025</time>
— <a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.fr>Creative Commons License BY-NC-ND 4.0</a></small></footer></div></body></html>