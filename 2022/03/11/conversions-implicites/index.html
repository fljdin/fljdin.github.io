<!doctype html><html lang=fr><head><title>Conversions implicites</title>
<link rel=stylesheet href=https://fljd.in/css/main.min.css><link rel=apple-touch-icon sizes=180x180 href=/ico/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/ico/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/ico/favicon-16x16.png><link rel=manifest href=/ico/site.webmanifest><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=UTF-8></head><body><div class="container content"><header class=homepage><h3 class=homepage-title><a href=/ title="Florent Jardin">Florent Jardin</a>
<small><a href=/index.xml><svg class="svg-icon"><use xlink:href="https://fljd.in/img/social-icons.svg#rss"/></svg></a>
<a href=https://fosstodon.org/@fljdin><svg class="svg-icon"><use xlink:href="https://fljd.in/img/social-icons.svg#mastodon"/></svg></a>
<a href=https://github.com/fljdin><svg class="svg-icon"><use xlink:href="https://fljd.in/img/social-icons.svg#github"/></svg></a>
<a href=https://www.linkedin.com/in/florent-jardin><svg class="svg-icon"><use xlink:href="https://fljd.in/img/social-icons.svg#linkedin"/></svg></a>
&nbsp;&nbsp;<a href=/conferences>Conférences</a>&nbsp;&nbsp;<a href=/archives>Archives</a>&nbsp;&nbsp;<a href=/a-propos>À propos</a></small></h3></header><main><article class=post><h1 class=post-title>Conversions implicites</a></h1><p class=post-date><time datetime=2022-03-11>11 mars 2022</time>
- 8 minutes de lecture</p><p>À l&rsquo;image d&rsquo;un langage de programmation classique, le SQL manipule des données
typées, comme les chaînes de caractères, les dates ou des entiers numériques.
Les opérations de transformations ou de comparaison diffèrent en fonction du
type de données ; il ne sera pas possible de comparer le caractère <code>A</code> avec le
chiffre <code>4</code> mais l&rsquo;opérateur <code>||</code> permettra la concaténation des deux éléments.</p><p>Dans cet article, je souhaite partager quelques anecdotes et problématiques de
terrain concernant cette particularité logicielle et comprendre les effets de
bord pour mieux les appréhender. Je prendrais un exemple assez spécifique du type
<code>oid</code> et d&rsquo;un risque de transtypage pouvant perturber le stockage de <em>Large
Objects</em> dans une table, voire leur destruction non désirée.</p><hr><h2 id=aucun-résultat-surprenant-ou-imprévisible>Aucun résultat surprenant ou imprévisible</h2><p>PostgreSQL dispose d&rsquo;un système complet pour la gestion du typage des données.
Chaque donnée est considérée par son type, permettant ainsi de le manipuler à
travers un ensemble d&rsquo;opérateurs, avec des comportements précis pour chaque type.</p><p>Les conversions implicites sont ces mécanismes qui assurent l&rsquo;alignement de deux
types de données pour réaliser (ou non) l&rsquo;opération demandée. La <a href=https://www.postgresql.org/docs/14/typeconv-overview.html target=_blank rel=noopener>documentation</a>
énumère les trois principes que respectent ces conversions :</p><ul><li>Les conversions implicites ne doivent jamais avoir de résultats surprenants
ou imprévisibles.</li><li>Il n&rsquo;y aura pas de surcharge depuis l&rsquo;analyseur ou l&rsquo;exécuteur si une requête
n&rsquo;a pas besoin d&rsquo;une conversion implicite de types. C&rsquo;est-à-dire que si une
requête est bien formulée et si les types sont déjà bien distinguables, alors
la requête devra s&rsquo;exécuter sans perte de temps supplémentaire et sans
introduire à l&rsquo;intérieur de celle-ci des appels à des conversions implicites
non nécessaires.</li><li>De plus, si une requête nécessite habituellement une conversion implicite pour
une fonction et si l&rsquo;utilisateur définit une nouvelle fonction avec les types
des arguments corrects, l&rsquo;analyseur devrait utiliser cette nouvelle fonction
et ne fera plus des conversions implicites en utilisant l&rsquo;ancienne fonction.</li></ul><p>Il est arrivé par le passé, qu&rsquo;une version majeure réduise la liste des conversions
implicites pour respecter les principes cités ci-dessus. Ce fut le cas de la
<a href=https://www.postgresql.org/docs/8.3/release-8-3.html#AEN88167 target=_blank rel=noopener>version 8.3</a> qui interdit (brutalement) le transtypage de données temporelles
(<code>date</code>, <code>time</code>) ou numérique (<code>int4</code>, etc.) en chaîne de caractère (<code>text</code>).
Tom Lane <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=31edbadf4af45dd4eecebcb732702ec6d7ae1819" target=_blank rel=noopener>proposa</a> une nouvelle implémentation de la représentation textuelle
d&rsquo;une donnée pour limiter le risque de surprise.</p><p>Certaines opérations devenaient également impossibles, obligeant les développeurs
à faire preuve de plus de rigueur. Les expressions suivantes nécessitaient alors
une réécriture pour forcer le transtypage avec l&rsquo;opérateur <code>::</code> ou la fonction
<code>CAST()</code> :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>substr</span><span class=p>(</span><span class=k>current_date</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>4</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=s2>&#34;year&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- ERROR: function substr(date, integer, integer) does not exist
</span></span></span><span class=line><span class=cl><span class=c1>--&gt; devient
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=n>substr</span><span class=p>(</span><span class=k>current_date</span><span class=p>::</span><span class=nb>text</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>4</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=s2>&#34;year&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=k>position</span><span class=p>(</span><span class=mi>5</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=s1>&#39;1234567890&#39;</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;5&#39;</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=s2>&#34;5&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- ERROR: function pg_catalog.position(unknown, integer) does not exist
</span></span></span><span class=line><span class=cl><span class=c1>--&gt; devient
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=k>position</span><span class=p>(</span><span class=k>CAST</span><span class=p>(</span><span class=mi>5</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=nb>text</span><span class=p>)</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=s1>&#39;1234567890&#39;</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;5&#39;</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=s2>&#34;5&#34;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>L&rsquo;exemple ci-après est inspiré des <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=blobdiff;f=src/test/regress/expected/foreign_key.out;h=3c0dd7f0872df01829d8e5a518c98e4b822a6ff1;hp=41c2f397882daf8d032f0dd12a6b74a4b867cf1b;hb=31edbadf4af45dd4eecebcb732702ec6d7ae1819;hpb=1120b99445a90ceba27f49e5cf86293f0628d06a" target=_blank rel=noopener>tests de regression</a>, mettant en jeu deux
tables avec une contrainte étrangère. Depuis la version majeure 8.3, le message
d&rsquo;erreur <code>foreign key constraint cannot be implemented</code> indique que la conversion
implicite n&rsquo;est plus possible.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=n>TEMP</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>pktable</span><span class=w> </span><span class=p>(</span><span class=n>id1</span><span class=w> </span><span class=n>int4</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=n>TEMP</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>fktable</span><span class=w> </span><span class=p>(</span><span class=n>x1</span><span class=w> </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>4</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>fktable</span><span class=w> </span><span class=k>ADD</span><span class=w> </span><span class=k>CONSTRAINT</span><span class=w> </span><span class=n>fk_id1_x1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>FOREIGN</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=n>x1</span><span class=p>)</span><span class=w> </span><span class=k>REFERENCES</span><span class=w> </span><span class=n>pktable</span><span class=p>(</span><span class=n>id1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- ERROR: foreign key constraint &#34;fk_id1_x1&#34; cannot be implemented
</span></span></span><span class=line><span class=cl><span class=c1>-- DETAIL: Key columns &#34;x1&#34; and &#34;id1&#34; are of incompatible types:
</span></span></span><span class=line><span class=cl><span class=c1>--         integer and character varying.
</span></span></span></code></pre></div><p>Bien que certains <a href=http://blog.ioguix.net/postgresql/2010/12/11/Problems-and-workaround-recreating-casts-with-8.3+.html target=_blank rel=noopener>contournements</a> étaient alors possibles avec l&rsquo;ajout de
nouveaux opérateurs ou de nouvelles conversions implicites, la réécriture des
requêtes et le bon choix des types de données furent vivement encouragés pour
dépasser les contraintes qu&rsquo;imposait cette version majeure.</p><hr><h2 id=ouin-ouin-je-préfère-microsoft-access>Ouin ouin je préfère Microsoft Access</h2><p>Pour une partie non-négligeable de la population, le langage SQL est fréquemment
associé à… Microsoft Access. Bien qu&rsquo;on ait beaucoup à redire sur cette
affirmation, il est d&rsquo;usage que les suites Office soient très (trop) majoritaires
sur les postes utilisateurs.</p><p>Parmi l&rsquo;un des besoins de conversion, lorsqu&rsquo;il est question de migrer vers
PostgreSQL, on retrouve la gestion du type <code>boolean</code> qui est représenté par un
entier. La correspondance assez répandue est <code>0</code> = <code>false</code> et tout le
reste = <code>true</code>. Or, lorsqu&rsquo;une migration de données a lieu et que la transformation
des entiers <code>0</code> et <code>1</code> présents dans les tables a été correctement réalisée au
format <code>boolean</code>, les requêtes SQL applicatives peuvent rencontrer des soucis
de conversions implicites :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>visitor</span><span class=w> </span><span class=p>(</span><span class=n>id</span><span class=w> </span><span class=nb>int</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=nb>text</span><span class=p>,</span><span class=w> </span><span class=n>is_online</span><span class=w> </span><span class=n>bool</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>visitor</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;florent&#39;</span><span class=p>,</span><span class=w> </span><span class=k>true</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>visitor</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>is_online</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>-</span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- ERROR: operator does not exist: boolean = integer
</span></span></span><span class=line><span class=cl><span class=c1>-- HINT: No operator matches the given name and argument types. 
</span></span></span><span class=line><span class=cl><span class=c1>--       You might need to add explicit type casts.
</span></span></span></code></pre></div><p>Une fois encore, la correction la plus appropriée serait d&rsquo;épurer l&rsquo;expression
booléenne avec uniquement la clause <code>WHERE is_online</code>. Pour celles et ceux qui
ne peuvent (ou ne veulent) pas procéder à la réécriture, Sim Zacks proposait sur
la <a href=https://www.postgresql.org/message-id/do4dpl%242f6t%241%40news.hub.org target=_blank rel=noopener>liste pgsql-general</a> un contournement au niveau des opérateurs dans
PostgreSQL. Dans la version ci-dessous, je m&rsquo;appuie sur la fonction native <code>bool()</code>
pour déterminer la correspondance booléenne d&rsquo;un entier.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=k>REPLACE</span><span class=w> </span><span class=k>FUNCTION</span><span class=w> </span><span class=n>pg_catalog</span><span class=p>.</span><span class=n>booleqint</span><span class=p>(</span><span class=n>bool</span><span class=p>,</span><span class=w> </span><span class=nb>integer</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>RETURNS</span><span class=w> </span><span class=nb>BOOLEAN</span><span class=w> </span><span class=k>STRICT</span><span class=w> </span><span class=k>IMMUTABLE</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>LANGUAGE</span><span class=w> </span><span class=k>SQL</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=err>$$</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>bool</span><span class=p>(</span><span class=err>$</span><span class=mi>2</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=err>$</span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=err>$$</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>OPERATOR</span><span class=w> </span><span class=n>pg_catalog</span><span class=p>.</span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>procedure</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pg_catalog</span><span class=p>.</span><span class=n>booleqint</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>leftarg</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>boolean</span><span class=p>,</span><span class=w> </span><span class=n>rightarg</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>integer</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>commutator</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>operator</span><span class=p>(</span><span class=n>pg_catalog</span><span class=p>.</span><span class=o>=</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>negator</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>operator</span><span class=p>(</span><span class=n>pg_catalog</span><span class=p>.</span><span class=o>!=</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>visitor</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>is_online</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>-</span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>--  id |  name   
</span></span></span><span class=line><span class=cl><span class=c1>-- ----+---------
</span></span></span><span class=line><span class=cl><span class=c1>--   1 | florent
</span></span></span></code></pre></div><hr><h2 id=précaution-pour-les-large-objects>Précaution pour les Large Objects</h2><p>Une donnée <code>oid</code> (<a href=https://www.postgresql.org/docs/14/datatype-oid.html target=_blank rel=noopener>doc</a>) est depuis peu, un type exclusivement réservé au
fonctionnement interne du catalogue PostgreSQL. Il s&rsquo;agit très simplement d&rsquo;un
entier encodé sur 4 octets, exactement comme le type <code>int4</code> ou <code>integer</code>. Et là
où la conversion implicite nous empêchait de trouver une correspondance entre une
chaîne de caractère et un entier, le type <code>oid</code> se comporte bien différemment.</p><p>Démonstration avec deux colonnes, respectivement <code>text</code> et <code>oid</code>. Lors de l&rsquo;ajout
d&rsquo;un enregistrement, le transtypage de la valeur <code>10000</code> (<code>integer</code>) vers un type
<code>text</code> ou <code>oid</code> ne pose aucune sorte de difficulté.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>test</span><span class=w> </span><span class=p>(</span><span class=n>col1</span><span class=w> </span><span class=nb>text</span><span class=p>,</span><span class=w> </span><span class=n>col2</span><span class=w> </span><span class=n>oid</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>test</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=mi>10000</span><span class=p>,</span><span class=w> </span><span class=mi>10000</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>La conversion inverse ne sera pas possible pour le type <code>text</code>, comme expliqué
plus haut avec une implémentation plus robuste introduite en version 8.3.
Cependant, rien n&rsquo;interdira l&rsquo;opération inverse pour le type <code>oid</code> vers <code>integer</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>col1</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>test</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>col1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10000</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- ERROR: operator does not exist: text = integer
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>col2</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>test</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>col2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10000</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>--  col2  
</span></span></span><span class=line><span class=cl><span class=c1>-- -------
</span></span></span><span class=line><span class=cl><span class=c1>--  10000
</span></span></span></code></pre></div><p>Il s&rsquo;agit d&rsquo;une conversion implicite basée sur un rapprochement strict de la
valeur binaire des deux données, que la <a href=https://www.postgresql.org/docs/14/sql-createcast.html target=_blank rel=noopener>documentation</a> décrit comme « deux
types coercibles binairement ».</p><blockquote><p>Deux types peuvent être coercibles binairement, ce qui signifie que le
transtypage peut être fait « gratuitement » sans invoquer aucune fonction.
Ceci impose que les valeurs correspondantes aient la même représentation interne.
Par exemple, les types text et varchar sont coercibles binairement dans les
deux sens.</p></blockquote><p>C&rsquo;est avec ce phénomène en tête que je peux vous parler des <em>Large Objects</em> !</p><p>À l&rsquo;instar du <a href=/2020/10/12/toast-la-meilleure-chose-depuis-le-pain-en-tranches/>mécanisme de <em>toasting</em></a> permettant le débordement d&rsquo;une donnée
supérieure à 8 ko dans un fichier dédié, les <em>Large Objects</em> sont centralisées
dans une table système nommée <code>pg_largeobject</code>. Des besoins comme le <em>streaming</em>
binaire ou le stockage au-delà de 1 Go, peuvent justifier leur utilisation en
lieu et place des types plus standards, comme <code>text</code> ou <code>bytea</code>.</p><p>Sauf que la gestion d&rsquo;un <code>lo</code> (<em>large object</em>, vous l&rsquo;avez ?) se fait grâce au
maintien d&rsquo;adresses logiques entre la colonne d&rsquo;un enregistrement et la table
système. Oui, un identifiant unique de type <code>oid</code>. Prenons une table <code>wallet</code>
dans laquelle nous décidons de stocker des documents volumineux sous forme de
<em>large objects</em>, disons le <a href=https://www.ipcc.ch/report/ar6/wg2/ target=_blank rel=noopener>dernier rapport du GIEC</a>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>wallet</span><span class=w> </span><span class=p>(</span><span class=n>title</span><span class=w> </span><span class=nb>text</span><span class=p>,</span><span class=w> </span><span class=n>content</span><span class=w> </span><span class=n>oid</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>wallet</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=s1>&#39;Climate Change 2022 - Summary for Policymakers&#39;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>lo_import</span><span class=p>(</span><span class=s1>&#39;IPCC_AR6_WGII_SummaryForPolicymakers.pdf&#39;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- INSERT 0 1
</span></span></span></code></pre></div><p>La consultation du fichier ne sera permise qu&rsquo;à travers des méthodes dédiées,
telle que <code>lo_get()</code>. Dans l&rsquo;exemple ci-dessous, je consulte les 10 premiers
octets du fichier PDF pour m&rsquo;assurer de son existence dans la base de données.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>content</span><span class=p>,</span><span class=w> </span><span class=n>lo_get</span><span class=p>(</span><span class=n>content</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>10</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>wallet</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>--  content |         lo_get         
</span></span></span><span class=line><span class=cl><span class=c1>-- ---------+------------------------
</span></span></span><span class=line><span class=cl><span class=c1>--    16811 | \x255044462d312e360d25
</span></span></span></code></pre></div><p>L&rsquo;identifiant <code>16811</code> de mon document est unique parmi les <em>large objects</em> et
garantit qu&rsquo;il puisse être reconstruit à l&rsquo;aide des méthodes associées. Que se
passe-t-il si l&rsquo;on change le type de la colonne <code>content</code> en autre chose, par
exemple en <code>integer</code> ?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>wallet</span><span class=w> </span><span class=k>ALTER</span><span class=w> </span><span class=k>COLUMN</span><span class=w> </span><span class=n>content</span><span class=w> </span><span class=k>TYPE</span><span class=w> </span><span class=nb>integer</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- ALTER TABLE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>content</span><span class=p>,</span><span class=w> </span><span class=n>lo_get</span><span class=p>(</span><span class=n>content</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>10</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>wallet</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>--  content |         lo_get         
</span></span></span><span class=line><span class=cl><span class=c1>-- ---------+------------------------
</span></span></span><span class=line><span class=cl><span class=c1>--    16811 | \x255044462d312e360d25
</span></span></span></code></pre></div><p>Puisque le type <code>oid</code> est coercible binairement avec le type <code>integer</code>, nous
n&rsquo;observons pas d&rsquo;erreur de conversion ni lors du changement du type de la colonne
ni lors de l&rsquo;appel <code>lo_get()</code>. À partir de cet instant, les choses deviennent
dangereuses pour le rapport du GIEC : par ignorance, un administrateur soucieux
des données larges orphelines décide de déclencher la commande <code>vacuumlo</code>
(<a href=https://www.postgresql.org/docs/14/vacuumlo.html target=_blank rel=noopener>doc</a>) :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ vacuumlo --verbose demo          
</span></span><span class=line><span class=cl>Connected to database <span class=s2>&#34;demo&#34;</span>
</span></span><span class=line><span class=cl>Successfully removed <span class=m>1</span> large objects from database <span class=s2>&#34;demo&#34;</span>.
</span></span></code></pre></div><p>Une donnée orpheline est considérée comme telle dès que son OID n&rsquo;apparaît dans
aucune colonne <code>oid</code> de la base de données. Or, avec la modification du type de
la colonne <code>content</code>, tous les documents de la table <code>wallet</code> sont supprimés
automatiquement de table <code>pg_largeobject</code>, détruits à jamais.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>content</span><span class=p>,</span><span class=w> </span><span class=n>lo_get</span><span class=p>(</span><span class=n>content</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>10</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>wallet</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- ERROR: large object 16811 does not exist
</span></span></span></code></pre></div><hr><h2 id=conclusion>Conclusion</h2><p>Les confusions peuvent être nombreuses avec la conversion implicite d&rsquo;un type
vers un autre. Les développeurs de PostgreSQL sont parvenus à construire un
système fiable pour interdire les transtypages illogiques, en demandant aux
utilisateurs d&rsquo;adapter leurs requêtes avec un meilleur usage des types pour
chacune des données à manipuler.</p><p>Les exemples cités dans cet article sont de véritables expériences de terrain et
je remercie mon collègue <a href=https://github.com/beaud76 target=_blank rel=noopener>Philippe</a> d&rsquo;avoir identifié la faiblesse du typage
<code>oid</code> dans le cadre d&rsquo;une maintenance par <code>vacuumlo</code>, et d&rsquo;avoir rendu possible
ce partage au plus grand nombre.</p></article><aside class=related><h3>Suggestion d'articles</h3><ul class=related-posts><li><a href=https://fljd.in/2022/06/29/dessine-moi-un-arbre-abstrait/>Dessine-moi un arbre (abstrait)
<small><time datetime=2022-06-29>29 juin 2022</time></small></a></li><li><a href=https://fljd.in/2022/04/21/halte-aux-regressions/>Halte aux régressions
<small><time datetime=2022-04-21>21 avr 2022</time></small></a></li><li><a href=https://fljd.in/2024/05/28/un-assistant-pour-copier-les-donnees-distantes/>Un assistant pour copier les données distantes
<small><time datetime=2024-05-28>28 mai 2024</time></small></a></li></ul></aside></main><footer class=footer><small>&copy; 2019-<time datetime=2024-05-28>2024</time>
— <a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.fr>Creative Commons License BY-NC-ND 4.0</a></small></footer></div></body></html>