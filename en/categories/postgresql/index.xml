<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>postgresql on Discovery notebook</title><link>https://fljd.in/en/categories/postgresql/</link><description>Recent content in postgresql on Discovery notebook</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>Florent Jardin</managingEditor><lastBuildDate>Wed, 29 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://fljd.in/en/categories/postgresql/index.xml" rel="self" type="application/rss+xml"/><item><title>Draw me an (abstract) tree</title><link>https://fljd.in/en/2022/06/29/draw-me-an-abstract-tree/</link><pubDate>Wed, 29 Jun 2022 00:00:00 +0000</pubDate><author>Florent Jardin</author><guid>https://fljd.in/en/2022/06/29/draw-me-an-abstract-tree/</guid><description>&lt;blockquote>
&lt;p>The parser stage creates a parse tree using only fixed rules about the syntactic
structure of SQL. It does not make any lookups in the system catalogs, so there
is no possibility to understand the detailed semantics of the requested operations.&lt;/p>
&lt;p>(Documentation: &lt;a href="https://www.postgresql.org/docs/14/parser-stage.html#id-1.10.3.6.4" target="_blank" rel="noopener">Transformation Process&lt;/a>)&lt;/p>
&lt;/blockquote>
&lt;p>What is going on from when a user sends his SQL query to getting back a data result?
This passionating question (by a limited amount of people, of course) has been
studied by Stefan Simkovics during his &lt;a href="https://archive.org/details/Enhancement_of_the_ANSI_SQL_Implementation_of_PostgreSQL/" target="_blank" rel="noopener">Master&amp;rsquo;s Thesis&lt;/a> at Vienna University of
Technology in 1998.&lt;/p>
&lt;p>His remarkable work was added in &lt;a href="https://www.postgresql.org/docs/14/overview.html" target="_blank" rel="noopener">official documentation&lt;/a> as &amp;ldquo;Overview of
PostgreSQL Internals&amp;rdquo;, which is intended to share Simkovics&amp;rsquo; research in a
simplified way to reach a larger audience.&lt;/p>
&lt;p>With this article, I&amp;rsquo;m thrilled to share recent thoughts about a subelement of
these internals, the parser. It relies on a similar approach to compiling by
using an advanced development pattern called &lt;a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="noopener">AST&lt;/a> (abstract syntax tree).&lt;/p></description></item><item><title>A brief history of backup label</title><link>https://fljd.in/en/2021/12/02/a-brief-history-of-backup-label/</link><pubDate>Thu, 02 Dec 2021 00:00:00 +0000</pubDate><author>Florent Jardin</author><guid>https://fljd.in/en/2021/12/02/a-brief-history-of-backup-label/</guid><description>&lt;p>For a long time, I remained ignorant about &lt;a href="http://www.interdb.jp/pg/pgsql09.html" target="_blank" rel="noopener">transaction logging mechanisms&lt;/a>
and PITR in PostgreSQL, although they were crucial in data durability. A better
understanding of these concepts would have helped me in a previous life, to be
more confident during a backup configuration and, well, during after-crash
intervention!&lt;/p>
&lt;p>By reading this post, I will come back to an amusing file that used to be a
topic of discussion over the past decade: the backup label file. What is it and
what is it used for? How has it be enhanced from its origin with PostgreSQL 8.0
and what could be expected from him over the next years?&lt;/p></description></item></channel></rss>