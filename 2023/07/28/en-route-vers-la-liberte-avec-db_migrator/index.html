<!doctype html><html lang=fr><head><title>En route vers la liberté avec db_migrator</title><link rel=stylesheet href=https://fljd.in/css/main.min.css><link rel=apple-touch-icon sizes=180x180 href=/ico/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/ico/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/ico/favicon-16x16.png><link rel=manifest href=/ico/site.webmanifest><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8></head><body><div class="container content"><header class=homepage><h3 class=homepage-title><a href=/ title="Florent Jardin">Florent Jardin</a>
<small><a href=/index.xml><svg class="svg-icon"><use xlink:href="https://fljd.in/img/social-icons.svg#rss"/></svg></a><a href=https://fosstodon.org/@fljdin><svg class="svg-icon"><use xlink:href="https://fljd.in/img/social-icons.svg#mastodon"/></svg></a><a href=https://github.com/fljdin><svg class="svg-icon"><use xlink:href="https://fljd.in/img/social-icons.svg#github"/></svg></a><a href=https://www.linkedin.com/in/florent-jardin><svg class="svg-icon"><use xlink:href="https://fljd.in/img/social-icons.svg#linkedin"/></svg></a>&nbsp;&nbsp;<a href=/conferences>Conférences</a>&nbsp;&nbsp;<a href=/archives>Archives</a>&nbsp;&nbsp;<a href=/a-propos>À propos</a></small></h3></header><main><article class=post><h1 class=post-title>En route vers la liberté avec db_migrator</a></h1><p class=post-date><time datetime=2023-07-28>28 juil 2023</time>
- 7 minutes de lecture</p><div class="message translation">This article is available in English: <a href=https://fljd.in/en/2023/07/28/on-the-road-to-freedom-with-db_migrator/>On the road to freedom with db_migrator</a>
<small>(2023-07-28)</small></div><p>J&rsquo;ai passé plusieurs semaines ces derniers mois à contribuer à l&rsquo;extension
<a href=https://github.com/cybertec-postgresql/db_migrator target=_blank rel=noopener>db_migrator</a>. Rédigée uniquement en PL/pgSQL, elle permet de migrer les schémas
et les données d&rsquo;un système de bases de données vers PostgreSQL à l&rsquo;aide des
données externes que j&rsquo;avais déjà présentées il y a <a href=/2021/07/16/parlons-un-peu-des-donnees-externes/>quelques années</a>.</p><p>Dans cet article, je présente le fonctionnement de l&rsquo;outil, sa philosophie et la
raison d&rsquo;être que je lui ai trouvée, alors même qu&rsquo;il rejoint l&rsquo;écosystème des
projets libres déjà bien installés dans le paysage de la migration. Que vaut-il
aux côtés d&rsquo;<a href=https://ora2pg.darold.net/ target=_blank rel=noopener>Ora2Pg</a> ou de <a href=https://pgloader.io/ target=_blank rel=noopener>pgloader</a> ?</p><hr><h2 id=db_migrator-entre-dans-larène>db_migrator entre dans l&rsquo;arène</h2><p>Mon intérêt pour ce projet remonte à décembre dernier, alors qu&rsquo;un <a href=https://blog.dalibo.com/2022/12/21/depart_philippe.html target=_blank rel=noopener>collègue de
chez Dalibo</a> nous laissait en héritage un <a href=https://github.com/dalibo/data2pg target=_blank rel=noopener>outil similaire</a> avec lequel il
lui était possible de copier les données d&rsquo;instances Oracle ou Sybase à l&rsquo;aide
de la technologie des <em>Foreign Data Wrappers</em> (FDW). Bien que cet outil soit
resté en alpha, beaucoup de bonnes idées y ont été expérimentées en interne.</p><p>La promesse des FDW réside dans le respect de la norme SQL/MED, à savoir qu&rsquo;une
instance PostgreSQL puisse s&rsquo;interfacer sur un autre système de stockage et en
manipuler les données à travers les tables externes avec de simples requêtes
SQL. Ainsi, pour peu qu&rsquo;une communauté ait développé le <em>wrapper</em>, il est
possible de consulter un catalogue distant, reproduire la structure des tables,
ses relations et ses contraintes, et de <a href=/2021/12/06/migrer-vers-postgresql/>rapatrier les données</a> vers
PostgreSQL.</p><p>Et <a href=https://github.com/cybertec-postgresql/db_migrator target=_blank rel=noopener>db_migrator</a> entre dans l&rsquo;arène.</p><p>Rendue publique en novembre 2019 par Laurenz Albe, connu pour sa contribution
active sur PostgreSQL depuis des décennies et également pour le développement de
<a href=https://github.com/laurenz/oracle_fdw target=_blank rel=noopener>oracle_fdw</a>, l&rsquo;extension se présente comme un outil générique avec lequel il
faut employer des <em>plugins</em> pour la prise en charge des FDW. Il est aisé d&rsquo;en
créer de nouveaux, comme j&rsquo;ai pu m&rsquo;en rendre compte avec le plugin
<a href=https://github.com/fljdin/mysql_migrator target=_blank rel=noopener>mysql_migrator</a>, écrit en quelques jours, grâce à la documentation très
complète de l&rsquo;<a href=https://github.com/cybertec-postgresql/db_migrator#plugin-api target=_blank rel=noopener>API des plugins</a>.</p><p>Après avoir installé les extensions avec <code>make install</code> ainsi que le FDW du bon
système, il est nécessaire de créer les objets dans la base de données qui va
contenir les futurs schémas et leurs données.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=n>EXTENSION</span><span class=w> </span><span class=n>mysql_fdw</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=n>EXTENSION</span><span class=w> </span><span class=n>mysql_migrator</span><span class=w> </span><span class=k>CASCADE</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=n>SERVER</span><span class=w> </span><span class=n>mysql</span><span class=w> </span><span class=k>FOREIGN</span><span class=w> </span><span class=k>DATA</span><span class=w> </span><span class=n>WRAPPER</span><span class=w> </span><span class=n>mysql_fdw</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>OPTIONS</span><span class=w> </span><span class=p>(</span><span class=k>host</span><span class=w> </span><span class=s1>&#39;mysql_db&#39;</span><span class=p>,</span><span class=w> </span><span class=n>fetch_size</span><span class=w> </span><span class=s1>&#39;1000&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>USER</span><span class=w> </span><span class=n>MAPPING</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=k>PUBLIC</span><span class=w> </span><span class=n>SERVER</span><span class=w> </span><span class=n>mysql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>OPTIONS</span><span class=w> </span><span class=p>(</span><span class=n>username</span><span class=w> </span><span class=s1>&#39;root&#39;</span><span class=p>,</span><span class=w> </span><span class=n>password</span><span class=w> </span><span class=s1>&#39;password&#39;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>L&rsquo;opération de migration peut être réalisée en une seule commande pour les cas
les plus simples (pas de procédure stockée, ni de types de colonnes exotiques)
avec la méthode <code>db_migrate()</code>. Sinon, en plusieurs étapes, s&rsquo;il est nécessaire
de faire des ajustements comme le changement du type de colonne ou le retrait
d&rsquo;une table dans le schéma cible.</p><p>Lors du développement de l&rsquo;extension <code>mysql_migration</code>, je suis parti de la base
d&rsquo;exemple <a href=https://dev.mysql.com/doc/sakila/en/ target=_blank rel=noopener>Sakila</a> fournie par MySQL afin d&rsquo;avoir une complexité exhaustive.
La première étape consiste à créer deux schémas internes, l&rsquo;un avec des tables
externes fournies par le plugin, l&rsquo;autre avec des tables de catalogue que l&rsquo;on
peut éditer avant que l&rsquo;extension ne poursuive la migration.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>db_migrate_prepare</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>plugin</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s1>&#39;mysql_migrator&#39;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>server</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s1>&#39;mysql&#39;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>only_schemas</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s1>&#39;{sakila}&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>Cette partie peut être relativement longue, puisqu&rsquo;elle va permettre de
rapatrier le modèle de données, que j&rsquo;appelle le catalogue, sous la forme de
plusieurs tables qui décrivent la structure des tables, le nom des colonnes ou
les contraintes qui leur sont associées. L&rsquo;extension importe également les
sources de toutes les procédures stockées, les fonctions, les vues, mais ne
réalise pas leur conversion en PL/pgSQL (vous ne vous rendez pas compte du
<a href=https://blog.dalibo.com/2020/12/21/migration_oracle_vers_postgresql.html target=_blank rel=noopener>travail que cela représente</a>).</p><p>Dans le cas de la migration de la base Sakila, il est nécessaire de faire
plusieurs modifications du catalogue. Comme le reste avec cette extension, toute
la préparation se réalise en SQL, ce qui rend facile l&rsquo;automatisation avec un
unique script en guise de configuration.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=cm>/* exclude bytea columns from migration */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>DELETE</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>pgsql_stage</span><span class=p>.</span><span class=n>columns</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>type_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;bytea&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/* quote character expression */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>UPDATE</span><span class=w> </span><span class=n>pgsql_stage</span><span class=p>.</span><span class=n>columns</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>SET</span><span class=w> </span><span class=n>default_value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>quote_literal</span><span class=p>(</span><span class=n>default_value</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>WHERE</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=n>regexp_like</span><span class=p>(</span><span class=n>default_value</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;^\-?[0-9]+$&#39;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>AND</span><span class=w> </span><span class=n>default_value</span><span class=w> </span><span class=o>&lt;&gt;</span><span class=w> </span><span class=s1>&#39;CURRENT_TIMESTAMP&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/* disable view migration */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>UPDATE</span><span class=w> </span><span class=n>pgsql_stage</span><span class=p>.</span><span class=n>views</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>migrate</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>false</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>On pourrait bien sûr aller plus loin, comme réinjecter la définition des vues
réécrites dans la table <code>pgsql_stage.views</code> ou activer la migration des
procédures en changeant la colonne <code>migrate</code> de la table
<code>pgsql_stage.functions</code>. Mais progressons avec l&rsquo;étape suivante.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>db_migrate_mkforeign</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>plugin</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s1>&#39;mysql_migrator&#39;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>server</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s1>&#39;mysql&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>db_migrate_tables</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>plugin</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s1>&#39;mysql_migrator&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>La première méthode <code>db_migrate_mkforeign()</code> va se charger de créer les schémas
et les séquences, puis les tables étrangères avec les colonnes au regard des
ajustements précédents. Ensuite, l&rsquo;étape la plus cruciale, on exécute la
fonction <code>db_migrate_tables()</code> : les tables vierges sont créées avec leurs
partitions si besoin, et pour chacune d&rsquo;entre elles, débute alors la copie des
données avec l&rsquo;instruction <code>INSERT INTO SELECT *</code>.</p><p>Les autres objets, tels que les index ou les contraintes, disposent de leur
propre méthode. Il est nécessaire de créer les fonctions avant ces derniers si
vous êtes confronté à des index fonctionnels ou que sais-je.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>db_migrate_functions</span><span class=p>(</span><span class=n>plugin</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s1>&#39;mysql_migrator&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>db_migrate_triggers</span><span class=p>(</span><span class=n>plugin</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s1>&#39;mysql_migrator&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>db_migrate_views</span><span class=p>(</span><span class=n>plugin</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s1>&#39;mysql_migrator&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>db_migrate_indexes</span><span class=p>(</span><span class=n>plugin</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s1>&#39;mysql_migrator&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>db_migrate_constraints</span><span class=p>(</span><span class=n>plugin</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=s1>&#39;mysql_migrator&#39;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><div class=message>Il se pourrait que ce mécanisme change à l&rsquo;avenir, notamment si je parviens à
concrétiser cette <a href=https://github.com/cybertec-postgresql/db_migrator/issues/26 target=_blank rel=noopener>issue</a> qui permettrait de découper les méthodes
<code>db_migrate_*()</code> en de plus petites étapes.</div><p>La fin de la migration consiste à supprimer les schémas temporaires dans
lesquels se trouvaient les tables du catalogue.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>db_migrate_finish</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><hr><h2 id=raison-dêtre-de-lextension>Raison d&rsquo;être de l&rsquo;extension</h2><p>Comme je le disais en introduction, c&rsquo;est assez surprenant de voir un nouvel
outil de migration émerger en 2023 (la version 1.0.0 est <a href=https://github.com/cybertec-postgresql/db_migrator/blob/master/CHANGELOG.md target=_blank rel=noopener>sortie en janvier</a>
avec mon patch sur l&rsquo;ajout du partitionnement). Dans le paysage open-source, nous
pouvons parler d&rsquo;<strong>Ora2Pg</strong> qui a sorti en juillet sa <a href=https://github.com/darold/ora2pg/releases/tag/v24.0 target=_blank rel=noopener>version 24.0</a> avec
le support de SQL Server ou bien de <strong>pgloader</strong> qui a une excellente réputation.</p><p>De très nombreux projets sont listés sur le <a href=https://wiki.postgresql.org/wiki/Converting_from_other_Databases_to_PostgreSQL target=_blank rel=noopener>wiki communautaire</a>. Certains
sont spécialisés pour un seul système, d&rsquo;autres en migrent plusieurs. Une très
grande majorité d&rsquo;entre eux sont propriétaires ou n&rsquo;ont plus de contribution
récente. La plupart sont des boîtes noires et leur documentation peut paraître
cryptique, voire quasi inexistante.</p><p>L&rsquo;écosystème est riche, je ne prétends pas tous les connaître, mais j&rsquo;ai une
intuition que je me forge depuis quelques années. L&rsquo;économie mondiale est en
surchauffe. Certaines sociétés se portent bien, d&rsquo;autres font des coupes
budgétaires. La transition vers un système libre et sans licence commerciale
comme PostgreSQL est toujours d&rsquo;actualité, peut-être même plus urgente
aujourd&rsquo;hui en comparaison à la décennie qui vient de s&rsquo;écouler.</p><p>Et pourtant, avec mes lunettes de DBA, je ne me satisfais pas encore des outils
qui existent. J&rsquo;aimerais qu&rsquo;il y ait une nouvelle alternative, quelque chose
d&rsquo;universel et à portée de tout le monde. Si je me tourne aujourd&rsquo;hui vers
<strong>db_migrator</strong>, ce serait pour les principaux atouts suivants :</p><ul><li><p>Une implémentation bas niveau au plus près de l&rsquo;instance : avec le PL/pgSQL
comme langage exclusif. Cela n&rsquo;aurait pas été possible bien sûr sans le
développement prolifique des <em><a href=https://wiki.postgresql.org/wiki/Foreign_data_wrappers target=_blank rel=noopener>Foreign Data Wrappers</a></em> pour un grand
nombre de systèmes ;</p></li><li><p>Une très grande flexibilité de configuration : puisque les ajustements se font avec
des requêtes <code>UPDATE</code> ou <code>DELETE</code> sur le catalogue. Pour peu que l&rsquo;on soit à l&rsquo;aise
avec le modèle de ce dernier, il devient facile de changer un comportement sans
consulter une documentation technique sur les options qui se présentent à nous ;</p></li><li><p>Une liberté dans l&rsquo;orchestration : à ce jour, les exécutions sont déclenchées de
façon séquentielle pour les index et les contraintes, mais l&rsquo;architecture de l&rsquo;outil
pourrait permettre que des outils externes soient responsables de consommer les
résultats de l&rsquo;extension et de déclencher les opérations en parallèle ;</p></li><li><p>Les plugins sont libres d&rsquo;enrichir la migration : si une opération n&rsquo;est pas
générique, il est tout à fait possible de fournir une méthode supplémentaire à
l&rsquo;aide du plugin. C&rsquo;est le cas de la copie incrémentale (et ses <a href=https://github.com/cybertec-postgresql/ora_migrator#replication-functions target=_blank rel=noopener>fonctions de
réplication</a>) du plugin <strong>ora_migrator</strong> ou bien la conversion des
auto-incréments en colonnes d&rsquo;identité avec le plugin <strong>mysql_migrator</strong>.</p></li></ul><p>Le chemin vers la liberté me semble encore long pour prétendre faire la moitié
de ce que propose déjà Ora2Pg, à commencer par la conversion automatique qui
n&rsquo;est pas du tout à l&rsquo;ordre du jour. Mais avec de petites avancées, régulières
et réfléchies, qui sait ?</p></article><aside class=related><h3>Suggestion d'articles</h3><ul class=related-posts><li><a href=https://fljd.in/2021/12/06/migrer-vers-postgresql/>Migrer vers PostgreSQL
<small><time datetime=2021-12-06>6 déc 2021</time></small></a></li><li><a href=https://fljd.in/2021/07/16/parlons-un-peu-des-donnees-externes/>Parlons un peu des données externes
<small><time datetime=2021-07-16>16 juil 2021</time></small></a></li><li><a href=https://fljd.in/2023/03/22/les-colonnes-generees/>Les colonnes générées
<small><time datetime=2023-03-22>22 mars 2023</time></small></a></li></ul></aside></main><footer class=footer><small>&copy; 2019-<time datetime=2023-10-11>2023</time>
— <a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.fr>Creative Commons License BY-NC-ND 4.0</a></small></footer></div></body></html>